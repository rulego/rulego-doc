---
title: SQL Reference
date: 2024-01-15 10:04:00
permalink: /pages/streamsql-sql/
article: false
author: 
  name: StreamSQL
  link: https://github.com/rulego/streamsql
---

# SQL Reference

This chapter provides complete SQL syntax reference supported by StreamSQL, including all supported clauses, functions, and operators.

## ðŸ“‹ SQL Syntax Overview

StreamSQL supports a subset of standard SQL syntax, specifically optimized for stream processing.

```sql
SELECT [DISTINCT] select_list
FROM stream
[WHERE condition]
[GROUP BY grouping_element [, ...]]
[HAVING condition]
[LIMIT count]
[WITH (option = value [, ...])]
```

StreamSQL supports a subset of standard SQL syntax, specifically optimized for stream processing scenarios. This chapter provides complete SQL syntax reference.

## SQL Syntax Overview

### Basic Query Structure

```sql
SELECT [DISTINCT] select_list
FROM stream_name
[WHERE condition]
[GROUP BY grouping_list]
[HAVING condition]
[ORDER BY ordering_list]
[LIMIT number]
[WITH (option_list)]
```

### Supported Clauses

| Clause | Required | Description |
|------|------|------|
| SELECT | Yes | Specify output fields |
| FROM | Yes | Specify data source |
| WHERE | No | Filter conditions |
| GROUP BY | No | Grouping and windows |
| HAVING | No | Aggregate result filtering |
| ORDER BY | No | Sorting (limited support) |
| LIMIT | No | Limit result count |
| WITH | No | Configuration options |

## SELECT Clause

SELECT clause defines query output fields and calculation expressions.

### Basic Syntax

```sql
SELECT column1, column2, expression AS alias
FROM stream
```

### Supported Selection Types

#### 1. Field Selection

```sql
-- Select all fields
SELECT * FROM stream

-- Select specific fields
SELECT deviceId, temperature FROM stream

-- Field alias
SELECT deviceId AS device, temperature AS temp FROM stream
```

#### 2. Nested Field Access

```sql
-- Dot notation for nested fields
SELECT device.info.name, device.location.building FROM stream

-- Deep nesting
SELECT sensor.data.temperature.value FROM stream
```

#### 3. Expression Calculation

```sql
-- Arithmetic expressions
SELECT temperature * 1.8 + 32 AS fahrenheit FROM stream

-- String concatenation
SELECT CONCAT(deviceId, '-', location) AS full_id FROM stream

-- Conditional expressions
SELECT CASE 
    WHEN temperature > 30 THEN 'hot'
    WHEN temperature < 10 THEN 'cold'
    ELSE 'normal'
END AS temp_level FROM stream
```

#### 4. Aggregate Functions

```sql
-- Basic aggregation
SELECT COUNT(*), AVG(temperature), MAX(humidity) FROM stream

-- Aggregation with grouping
SELECT deviceId, AVG(temperature) FROM stream GROUP BY deviceId
```

### DISTINCT Deduplication

```sql
-- Deduplication query
SELECT DISTINCT deviceType FROM stream

-- Multi-field deduplication
SELECT DISTINCT deviceId, location FROM stream
```

### Basic Syntax

```sql
SELECT column1, column2, ...
SELECT expression AS alias
SELECT *
SELECT DISTINCT column1
```

### Field Selection

#### 1. Direct Field Reference
```sql
-- Select specific fields
SELECT deviceId, temperature, humidity FROM stream

-- Select all fields 
SELECT * FROM stream
```

#### 2. Expression Calculation
```sql
-- Arithmetic expressions
SELECT deviceId, temperature * 1.8 + 32 as fahrenheit FROM stream

-- String concatenation
SELECT CONCAT(deviceId, '_', status) as device_status FROM stream

-- Conditional expressions
SELECT deviceId,
       CASE 
           WHEN temperature > 30 THEN 'HIGH'
           WHEN temperature > 20 THEN 'NORMAL' 
           ELSE 'LOW'
       END as temp_level
FROM stream
```

#### 3. Function Calls
```sql
-- Built-in functions
SELECT deviceId, UPPER(status), ABS(temperature) FROM stream

-- Aggregate functions
SELECT deviceId, AVG(temperature), COUNT(*) FROM stream
GROUP BY deviceId, TumblingWindow('1m')

-- Custom functions
SELECT deviceId, custom_function(temperature) FROM stream
```

### Aliases (AS)

```sql
-- Field alias
SELECT temperature AS temp, humidity AS hum FROM stream

-- Expression alias 
SELECT temperature * 1.8 + 32 AS fahrenheit FROM stream

-- AS keyword can be omitted
SELECT temperature temp, humidity hum FROM stream
```

### DISTINCT

```sql
-- Deduplication (used in window aggregation)
SELECT DISTINCT deviceId, location 
FROM stream
GROUP BY deviceId, TumblingWindow('1m')
```

## FROM Clause

FROM clause specifies the data source, in StreamSQL it is always `stream`.

```sql
-- Standard FROM clause
SELECT * FROM stream

-- FROM clause is always required
SELECT deviceId FROM stream
```

## WHERE Clause

WHERE clause filters data before window processing and aggregation.

### Basic Syntax

```sql
SELECT deviceId, temperature
FROM stream
WHERE temperature > 25 AND humidity < 80
```

### Supported Conditions

#### 1. Comparison Operators
```sql
-- Numeric comparison
SELECT * FROM stream WHERE temperature > 25
SELECT * FROM stream WHERE humidity <= 60
SELECT * FROM stream WHERE pressure != 1013.25

-- String comparison
SELECT * FROM stream WHERE deviceType = 'sensor'
SELECT * FROM stream WHERE location LIKE 'building_%'

-- NULL check
SELECT * FROM stream WHERE temperature IS NOT NULL
SELECT * FROM stream WHERE humidity IS NULL
```

#### 2. Logical Operators
```sql
-- AND, OR, NOT
SELECT * FROM stream 
WHERE temperature > 25 AND humidity < 80

SELECT * FROM stream 
WHERE deviceType = 'sensor' OR deviceType = 'actuator'

SELECT * FROM stream 
WHERE NOT (temperature < 0)
```

#### 3. Range Conditions
```sql
-- BETWEEN...AND
SELECT * FROM stream 
WHERE temperature BETWEEN 20 AND 30

-- IN operator
SELECT * FROM stream 
WHERE deviceType IN ('sensor', 'thermostat', 'humidity')
```

#### 4. String Pattern Matching
```sql
-- LIKE pattern matching
SELECT * FROM stream WHERE deviceId LIKE 'sensor_%'
SELECT * FROM stream WHERE location LIKE '%building%'

-- NOT LIKE
SELECT * FROM stream WHERE deviceId NOT LIKE 'test_%'
```

#### 5. Complex Expressions
```sql
-- Nested field filtering
SELECT * FROM stream 
WHERE device.info.status = 'active' 
  AND sensor.temperature > 25

-- Mathematical expressions
SELECT * FROM stream 
WHERE ABS(temperature - 25) > 5
```

## GROUP BY Clause

GROUP BY clause groups data for aggregation operations and defines window types.

### Window Functions

#### 1. Tumbling Window
```sql
-- Basic tumbling window
SELECT AVG(temperature) 
FROM stream 
GROUP BY TumblingWindow('5m')

-- With grouping
SELECT deviceId, AVG(temperature) 
FROM stream 
GROUP BY deviceId, TumblingWindow('5m')
```

#### 2. Sliding Window
```sql
-- Basic sliding window
SELECT AVG(temperature) 
FROM stream 
GROUP BY SlidingWindow('10m', '2m')

-- With grouping
SELECT deviceId, AVG(temperature) 
FROM stream 
GROUP BY deviceId, SlidingWindow('10m', '2m')
```

#### 3. Counting Window
```sql
-- Basic counting window
SELECT AVG(temperature) 
FROM stream 
GROUP BY CountingWindow(100)

-- With grouping
SELECT deviceId, AVG(temperature) 
FROM stream 
GROUP BY deviceId, CountingWindow(100)
```

#### 4. Session Window
```sql
-- Basic session window
SELECT AVG(temperature) 
FROM stream 
GROUP BY SessionWindow('5m')

-- With grouping
SELECT deviceId, AVG(temperature) 
FROM stream 
GROUP BY deviceId, SessionWindow('5m')
```

### Grouping Fields

```sql
-- Single field grouping
SELECT deviceId, AVG(temperature) 
FROM stream 
GROUP BY deviceId, TumblingWindow('1m')

-- Multiple field grouping
SELECT deviceId, location, AVG(temperature) 
FROM stream 
GROUP BY deviceId, location, TumblingWindow('1m')
```

## HAVING Clause

HAVING clause filters results after aggregation calculations.

### Basic Syntax

```sql
SELECT deviceId, AVG(temperature) as avg_temp
FROM stream 
GROUP BY deviceId, TumblingWindow('1m')
HAVING AVG(temperature) > 25
```

### Usage Examples

#### 1. Aggregate Value Filtering
```sql
-- Filter by average temperature
SELECT deviceId, AVG(temperature) as avg_temp
FROM stream 
GROUP BY deviceId, TumblingWindow('5m')
HAVING avg_temp > 30

-- Filter by data count
SELECT deviceId, COUNT(*) as data_count
FROM stream 
GROUP BY deviceId, TumblingWindow('1m')
HAVING data_count > 100
```

#### 2. Complex Conditions
```sql
-- Multiple aggregate conditions
SELECT deviceId, 
       AVG(temperature) as avg_temp,
       MAX(temperature) as max_temp,
       MIN(temperature) as min_temp
FROM stream 
GROUP BY deviceId, TumblingWindow('10m')
HAVING avg_temp > 25 AND max_temp - min_temp > 10
```

## ORDER BY Clause

ORDER BY clause sorts query results. In stream processing, sorting is only supported within the same window.

### Basic Syntax

```sql
SELECT deviceId, temperature
FROM stream
ORDER BY temperature DESC
LIMIT 10
```

### Usage Examples

#### 1. Single Field Sorting
```sql
-- Sort by temperature descending
SELECT deviceId, temperature
FROM stream
ORDER BY temperature DESC

-- Sort by timestamp ascending
SELECT deviceId, temperature, timestamp
FROM stream
ORDER BY timestamp ASC
```

#### 2. Multi-field Sorting
```sql
-- Sort by device first, then by temperature
SELECT deviceId, temperature
FROM stream
ORDER BY deviceId ASC, temperature DESC
```

## LIMIT Clause

LIMIT clause restricts the number of returned results.

### Basic Syntax

```sql
SELECT deviceId, temperature
FROM stream
LIMIT 10
```

### Usage Examples

#### 1. Limit Result Count
```sql
-- Return top 5 results
SELECT deviceId, temperature
FROM stream
ORDER BY temperature DESC
LIMIT 5

-- Return first 100 records
SELECT * FROM stream
LIMIT 100
```

#### 2. Combined with WHERE
```sql
-- Limit filtered results
SELECT deviceId, temperature
FROM stream
WHERE temperature > 30
LIMIT 20
```

## WITH Clause

The WITH clause defines query options, mainly to enable event-time windows by specifying the timestamp field and (for integer timestamps) the time unit.

### Basic Syntax

```sql
SELECT columns FROM stream
[WHERE condition]
[GROUP BY grouping]
WITH (option = value [, ...])
```

### Core Effect

- No `WITH (TIMESTAMP=...)`: processing time. Windows use arrival time; record time fields are ignored.
- With `WITH (TIMESTAMP='field')`: event time. Windows use the given field; late arrivals are counted into the correct window.

### Options

1) TIMESTAMP â€” event time field  
Syntax:
```sql
WITH (TIMESTAMP='field_name')
```
Examples:
```sql
SELECT COUNT(*) FROM stream
GROUP BY TumblingWindow('5m')
WITH (TIMESTAMP='order_time')

SELECT deviceId, AVG(temperature)
FROM stream
GROUP BY deviceId, TumblingWindow('1m')
WITH (TIMESTAMP='event_time')
```
Notes: If the field is missing/empty, current time is used as a fallback.

2) TIMEUNIT â€” unit for integer timestamps  
Syntax:
```sql
WITH (TIMEUNIT='ns'|'ms'|'ss'|'mi'|'hh'|'dd')
```
Examples:
```sql
WITH (TIMESTAMP='event_time', TIMEUNIT='ms')
WITH (TIMESTAMP='timestamp', TIMEUNIT='ss')
```
Notes: Not needed for `time.Time`; required for integer (`int64`). Default: `ms`.

3) MAXOUTOFORDERNESS â€” max out-of-order tolerance  
Purpose: `watermark = max(event_time) - MaxOutOfOrderness`.  
Syntax:
```sql
WITH (MAXOUTOFORDERNESS='500ms'|'5s'|'2m'|'1h')
```
Example:
```sql
WITH (TIMESTAMP='event_time', MAXOUTOFORDERNESS='5s')
```
Notes: Event-time only. Larger values delay window triggering but tolerate disorder.

4) ALLOWEDLATENESS â€” allowed lateness after trigger  
Purpose: keep window open to accept late data until `watermark >= window_end + AllowedLateness`.  
Syntax:
```sql
WITH (ALLOWEDLATENESS='2s'|'1m'|...)
```
Examples:
```sql
WITH (TIMESTAMP='event_time', ALLOWEDLATENESS='2s')
WITH (TIMESTAMP='timestamp', ALLOWEDLATENESS='1m')
```
Notes: Event-time only. Default `0` closes immediately.

5) IDLETIMEOUT â€” idle source timeout  
Purpose: when the source is idle longer than this, advance watermark by processing time so windows can close.  
Syntax:
```sql
WITH (IDLETIMEOUT='5s'|'2m'|...)
```
Examples:
```sql
WITH (TIMESTAMP='event_time', IDLETIMEOUT='5s')
WITH (TIMESTAMP='timestamp', IDLETIMEOUT='2m')
```
Notes: Event-time only. Default `0` (disabled).

### Examples

Event time:
```sql
SELECT COUNT(*) AS order_count,
       SUM(amount) AS total_amount,
       AVG(amount) AS avg_amount
FROM stream
GROUP BY TumblingWindow('5m')
WITH (TIMESTAMP='order_time')
```

Processing time:
```sql
SELECT COUNT(*) AS order_count,
       SUM(amount) AS total_amount
FROM stream
GROUP BY TumblingWindow('5m')
```

### Watermark Workflow

- On arrival, update watermark: `max(event_time) - MaxOutOfOrderness`
- Trigger when `watermark >= window_end`
- Keep open until `watermark >= window_end + AllowedLateness`
- If idle for `IDLETIMEOUT`, use `currentProcessingTime - MaxOutOfOrderness` to advance watermark

## Complete Query Examples

### Basic Queries

#### 1. Simple Filtering
```sql
SELECT deviceId, temperature, humidity
FROM stream
WHERE temperature > 25 AND humidity < 80
```

#### 2. Aggregation with Window
```sql
SELECT deviceId, 
       AVG(temperature) as avg_temp,
       MAX(temperature) as max_temp,
       COUNT(*) as data_count
FROM stream
GROUP BY deviceId, TumblingWindow('5m')
```

#### 3. Complex Aggregation
```sql
SELECT deviceId, location,
       AVG(temperature) as avg_temp,
       STDDEV(temperature) as temp_std,
       PERCENTILE(temperature, 0.95) as temp_95p
FROM stream
GROUP BY deviceId, location, SlidingWindow('10m', '2m')
HAVING avg_temp > 25
ORDER BY avg_temp DESC
LIMIT 10
```

### Advanced Queries

#### 1. Nested Field Processing
```sql
SELECT device.info.name as device_name,
       device.location.building as building,
       AVG(sensor.temperature.value) as avg_temp,
       MAX(sensor.humidity.value) as max_humidity
FROM stream
WHERE device.info.status = 'active'
GROUP BY device.info.name, device.location.building, TumblingWindow('1m')
```

#### 2. Conditional Aggregation
```sql
SELECT deviceId,
       COUNT(CASE WHEN temperature > 30 THEN 1 END) as high_temp_count,
       COUNT(CASE WHEN temperature BETWEEN 20 AND 30 THEN 1 END) as normal_temp_count,
       COUNT(CASE WHEN temperature < 20 THEN 1 END) as low_temp_count
FROM stream
GROUP BY deviceId, TumblingWindow('1m')
```

#### 3. Time-based Analysis
```sql
SELECT deviceId,
       DATE_FORMAT(window_start(), 'HH:mm') as time_slot,
       AVG(temperature) as avg_temp,
       COUNT(*) as data_count
FROM stream
GROUP BY deviceId, TumblingWindow('1h')
ORDER BY time_slot ASC
```

## Error Handling

### Common Error Types

#### 1. Syntax Errors
```sql
-- Error: Missing FROM clause
SELECT deviceId, temperature

-- Error: Invalid window function
SELECT deviceId FROM stream GROUP BY InvalidWindow('5m')
```

#### 2. Type Errors
```sql
-- Error: Type mismatch in WHERE clause
SELECT * FROM stream WHERE temperature = 'invalid'

-- Error: Invalid aggregation
SELECT deviceId, temperature FROM stream GROUP BY deviceId
```

#### 3. Configuration Errors
```sql
-- Error: Invalid option
SELECT * FROM stream WITH (INVALID_OPTION='value')
```

### Best Practices

1. **Always test queries with sample data**
2. **Use proper data types for comparisons**
3. **Validate window sizes and time units**
4. **Check for NULL values in critical fields**
5. **Use meaningful aliases for complex expressions**
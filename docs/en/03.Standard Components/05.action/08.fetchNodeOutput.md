---
title: fetchNodeOutput
article: false
author: 
  name: rulego
  link: https://github.com/rulego/rulego
date: 2025-01-27 10:00:00
permalink: /pages/fetch-node-output/
---

`fetchNodeOutput` component: <Badge text="v0.33.0+"/> Component for retrieving specified node output. Used to get the output message of a target node and pass it to the next node.

## Background

In traditional rule chain processing, components can only access the output of the previous node as input, which creates limitations in certain complex scenarios. For example, after conditional branch processing, when you need to retrieve output data from a specific node within a branch, traditional approaches cannot directly achieve this.

The `fetchNodeOutput` component solves this problem by allowing retrieval of output from any previously executed node in the rule chain, enabling true cross-node data passing.

## Features

- **Cross-node data passing**: Retrieve target node's output message by node ID, breaking through traditional linear data flow limitations
- **Automatic dependency management**: Automatically establish node dependencies to enable output caching
- **Output reuse**: Support multiple nodes reusing the same node's output data
- **Conditional branch merging**: Suitable for data merging scenarios after conditional branches
- **Flexible data retrieval**: Can retrieve output from any previously executed node in the rule chain, not restricted by node execution order

## Configuration

| Field      | Type       | Description          | Default Value |
|------------|------------|----------------------|---------------|
| nodeId     | string     | Target node ID to retrieve output message from | None |

## Working Principle

### Dependency Mechanism

This component uses a dependency mechanism to ensure that the target node's output can be accessed:

1. **Initialization Phase**: Automatically calls `chainCtx.AddNodeDependency()` in the `Init()` method to establish dependency relationships
2. **Output Caching**: Only nodes with established dependencies will cache output data
3. **Data Access**: Access target node's cached output through the `GetNodeRuleMsg()` method

### Execution Flow

1. When the component receives a message, it searches for the target node's output using `nodeId`
2. If the target node's output is found, it passes it to the success chain
3. If no output is found or dependency relationship is not established, it passes the original message to the failure chain

## Use Cases

### Cross-node Data Passing

```json
{
  "id": "fetchOutput1",
  "type": "fetchNodeOutput",
  "name": "Get Data Processing Result",
  "configuration": {
    "nodeId": "dataProcessor"
  }
}
```

### Conditional Branch Merging

```json
{
  "ruleChain": {
    "name": "Conditional Branch Processing",
    "root": true,
    "debugMode": false
  },
  "metadata": {
    "nodes": [
      {
        "id": "condition",
        "type": "jsFilter",
        "name": "Condition Check",
        "configuration": {
          "jsScript": "return msg.temperature > 30;"
        }
      },
      {
        "id": "highTempProcess",
        "type": "jsTransform",
        "name": "High Temperature Processing",
        "configuration": {
          "jsScript": "msg.alert = 'high temperature'; return {msg: msg, metadata: metadata, msgType: msgType};"
        }
      },
      {
        "id": "normalProcess",
        "type": "jsTransform",
        "name": "Normal Processing",
        "configuration": {
          "jsScript": "msg.status = 'normal'; return {msg: msg, metadata: metadata, msgType: msgType};"
        }
      },
      {
        "id": "fetchHigh",
        "type": "fetchNodeOutput",
        "name": "Fetch High Temperature Result",
        "configuration": {
          "nodeId": "highTempProcess"
        }
      },
      {
        "id": "fetchNormal",
        "type": "fetchNodeOutput",
        "name": "Fetch Normal Processing Result",
        "configuration": {
          "nodeId": "normalProcess"
        }
      },
      {
        "id": "finalLog",
        "type": "log",
        "name": "Final Log",
        "configuration": {
          "jsScript": "return 'Final result: ' + JSON.stringify(msg);"
        }
      }
    ],
    "connections": [
      {
        "fromId": "condition",
        "toId": "highTempProcess",
        "type": "True"
      },
      {
        "fromId": "condition",
        "toId": "normalProcess",
        "type": "False"
      },
      {
        "fromId": "highTempProcess",
        "toId": "fetchNormal",
        "type": "Success"
      },
      {
        "fromId": "normalProcess",
        "toId": "fetchHigh",
        "type": "Success"
      },
      {
        "fromId": "fetchHigh",
        "toId": "finalLog",
        "type": "Success"
      },
      {
        "fromId": "fetchNormal",
        "toId": "finalLog",
        "type": "Success"
      }
    ]
  }
}
```

## Usage Guidelines

:::warning Important
- Must ensure the target node ID exists and has completed execution
- Dependency relationships are automatically established during component initialization, no manual configuration required
- If the target node has not produced output or dependency relationship is not established, the message will be routed to the failure chain
- **Recommend properly planning node execution order when designing rule chains, prioritizing natural data flow and avoiding excessive reliance on cross-node data passing**
- Cross-node data passing increases rule chain complexity and maintenance difficulty, use with caution
:::

:::tip Best Practices
- Ensure the target node has executed and produced output before using this component
- In complex conditional branch scenarios, multiple `fetchNodeOutput` components can be used to collect results from different branches
- Combine with other components (such as `jsTransform`) for further processing of retrieved outputs
- Besides using the `fetchNodeOutput` component, you can also retrieve other nodes' outputs through [Component Configuration Variables](/en/pages/baa05c/) syntax, such as: `${node1.msg.temperature}`, `${sensor2.metadata.deviceId}`, etc.
- Prioritize designing linear or tree-structured data flows to reduce cross-dependencies between nodes
:::
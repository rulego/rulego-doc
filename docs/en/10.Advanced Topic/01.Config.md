---
title: Config
article: false
author: 
  name: rulego
  link: https://github.com/rulego/rulego
date: 2023-09-13 21:24:41
permalink: /pages/d59341/
---

The config of the rule engine instance [Config](https://github.com/rulego/rulego/blob/main/api/types/config.go) is a global configuration. You can modify the config by the following way:

```go
config := rulego.NewConfig()
ruleEngine, err := rulego.New("rule01", []byte(ruleChainFile), rulego.WithConfig(config))
```

## OnDebug

Type: `func(flowType string, nodeId string, msg RuleMsg, relationType string, err error)`
- **flowType:** IN/OUT, the event type of flowing into (IN) or out of (OUT) the component
- **nodeId:** node ID
- **msg:** message structure, where the msg id is unique
- **relationType:** if flowType=IN, it represents the connection relationship between the previous node and this node, such as (True/False); if flowType=OUT, it represents the connection relationship between this node and the next node, such as (True/False)
- **err:** error information

Node debugging information callback global function. The In and Out processes of the rule chain node will be triggered after setting `debugMode=true` in the node configuration. You can record the log and execution situation of each node in this callback function, such as: time consumption, input message and output message.
Support dynamic setting of the node's `debugMode` field to turn it on or off.

:::tip
`OnDebug` callback function contains custom logic that is triggered asynchronously, and the execution order cannot be guaranteed.
:::

Visualization interface reference:
![img](/img/ondebug-view.png)

## OnEnd (deprecated)
(deprecated, use types.WithOnEnd instead)

Type: `func(msg RuleMsg, err error)`
- **msg:** the msg after the end point component processing
- **err:** error information

Rule chain execution completion callback global function, if the rule chain has multiple end points, it will be executed multiple times.
For example: after executing s1, s2, s3, and s4 are triggered at the same time, then the onEnd event will be triggered 3 times, and msg are the execution results of s2, s3, and s4 respectively. The rule chain is as follows:

![img](/img/chain/onend_example.png)

::: tip
The OnEnd function configured by config is global for the rule chain engine instance. You can also configure the end callback function for each message, using the following method:
```go
ruleEngine.OnMsg(msg, types.WithOnEnd(func(ctx types.RuleContext,msg types.RuleMsg, err error) {
    //End callback function 
}))
```

If you wish to execute a function once after the completion of rule chain processing, you can use the following method:
```go
ruleEngine.OnMsg(msg, types.WithOnAllNodeCompleted(func() {
    // Processing after completion
}))
```
:::

## ScriptMaxExecutionTime

Type: `time.Duration`

JS script execution timeout, default 2000 milliseconds.

## Pool


Type: `types.Pool`

Coroutine pool interface, if not configured, use go func method.

Use the built-in `pool.WorkerPool` by default. Compatible with ants coroutine pool, you can use ants coroutine pool implementation, you need to import the corresponding library yourself. For example:

```go
pool, _ := ants.NewPool(math.MaxInt32)
config := rulego.NewConfig(types.WithPool(pool))
```

::: tip
The built-in `pool.WorkerPool` is based on the implementation of FastHttp, which has higher performance and saves memory than `ants`.
:::

## ComponentsRegistry

Type: `types.ComponentRegistry`

Component library registrar, use `rulego.Registry` by default

## Parser

Type: `types.Parser`

Rule chain parsing interface, use `rulego.JsonParser` by default, you can implement custom rule chain DSL.

## Logger

Type: `types.Logger`

Log recording interface, use `DefaultLogger()` by default. [log component](/en/pages/020050/) uses this recorder.

## Properties


Type: `types.Metadata`

Global properties, key-value form.

The rule chain node configuration can replace the content of the variable by using `${global.propertyKey}` or `${metadataKey}`.

- Among them, `global.` is a built-in variable, which means to get the content from config.Properties for replacement (the replacement logic is executed only once when the node is initialized).
- `${metadataKey}` is obtained from the message metadata for replacement (the replacement logic is executed every time the node processes the message).

> Note: There can be no spaces in `${}`.

::: tip
In addition, you can also get the global Properties variable value when the js script is running, the calling method is:
```go
var value=global.propertyKey;
```
:::

Use example reference: [node_config](https://github.com/rulego/rulego/tree/main/examples/node_config/node_config.go)

## Udf

Type: `map[string]interface{}`

Register custom Golang functions and native scripts, which can be directly called by the script engine at runtime. This feature enables js and other script engines to have the ability to call Golang functions and extend native script functions.

Example:
```go
config := rulego.NewConfig()

//Get global variables at js script runtime: global.xx
config.Properties.PutValue("globalValue", "addValueFromConfig")

//Register custom function
config.RegisterUdf("add", func(a, b int) int {
    return a + b
})
config.RegisterUdf("handleMsg", func(msg map[string]interface{}, metadata map[string]string, msgType string) string {
    msg["returnFromGo"] = "returnFromGo"
    _, ok := rulego.Get("aa")
    msg["hasAaRuleChain"] = ok
    return "returnFromGoMsgType"
})
```

Register native scripts using `types.Script` to encapsulate the script content, the default is `Js` type, example:
```go
// Use: utilsFunc.dateFormat(new Date(), "yyyyMMddhh")
config.RegisterUdf(
"utilsFunScript", types.Script{
Type: types.Js,
Content: `var utilsFunc={
            dateFormat:function(date,fmt){
               var o = {
                 "M+": date.getMonth() + 1,
                 /*month*/ "d+": date.getDate(),
                 /*day*/ "h+": date.getHours(),
                 /*hour*/ "m+": date.getMinutes(),
                 /*minute*/ "s+": date.getSeconds(),
                 /*second*/ "q+": Math.floor((date.getMonth() + 3) / 3),
                 /*quarter*/ S: date.getMilliseconds() /*millisecond*/,
               };
               fmt = fmt.replace(/(y+)/, function(match, group) {
                 return (date.getFullYear() + "").substr(4 - group.length); 
               });
               for (var k in o) {
                 fmt = fmt.replace(new RegExp("(" + k + ")"), function(match, group) { 
                   return group.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length); 
                 });
               }
               return fmt;
            },
            isArray:function(arg){
              if (typeof Array.isArray === "undefined") {
                return Object.prototype.toString.call(arg) === "[object Array]";
              }
              return Array.isArray(arg);
            }
          };`,
})
```

To invoke in the js script:
```javascript
//Call the global configuration parameters
var value=global.globalValue;
msg['addField2']=value;
//Call the custom golang function add
msg['addValue']=add(1,5);
//Format the time
msg['today']=utilsFunc.dateFormat(new Date(), "yyyyMMddhh");
//Call the custom golang function handleMsg
msgType=handleMsg(msg,metadata,msgType);
return {'msg':msg,'metadata':metadata,'msgType':msgType};
```

For usage examples: [node_config](https://github.com/rulego/rulego/tree/main/examples/node_config/node_config.go)

## Aspects

Typeï¼š`[]Aspect`

[AOP](/en/pages/a1ed6c/) aspects list.For examples:
```go
//add SkipFallbackAspect
config := rulego.NewConfig(
	types.WithAspects(&aspect.SkipFallbackAspect{ErrorCountLimit: 3, LimitDuration: time.Second * 10})
)
```

## NodeClientInitNow

Type: `bool`  
Specifies whether components of the network client class (e.g., MQTT client components, Kafka client components, etc.) should be initialized immediately during initialization. The default is `false`, meaning they are initialized only when the component is first called.

- `true`: Initialize immediately during initialization. If initialization fails, the rule chain will not start.
- `false`: Initialize only when the component is first called. If initialization fails, the rule chain will start, but the component call will fail.

## AllowCycle

Type: `bool`  
Specifies whether nodes in the rule chain are allowed to have cyclic dependencies. The default is `false`, meaning they are not allowed.

## Cache
Type: `types.Cache`  

The cache is used for data sharing between different rule chains or between different execution contexts within the same rule chain instance. The cache levels are `chain` and `global`.  
The framework provides operations for both levels of cache within the same cache instance. The cache operations are as follows:

### Operating Cache in JS Scripts
Cache operations can be performed in JS script-related components, such as [JS Script Transformer](/pages/794696/) and [JS Script Filter](/pages/8269e5/), by obtaining the cache object from the built-in variable `$ctx` and calling the corresponding methods.
```javascript
let cache = $ctx.ChainCache(); // Get the current rule chain cache, operating within the current rule chain namespace.
// let cache = $ctx.GlobalCache(); // Get the global cache, operating within the global namespace.
let err = cache.Set("key", "value"); // Set cache with no expiration.
let err = cache.Set("key2", "value2", "10m"); // Set cache to expire after 10 minutes.
let value = cache.Get("key1"); // Retrieve cache.
let ok = cache.Has("key1"); // Check if the cache exists.
let err = cache.Delete("key1"); // Delete cache.
let values = cache.GetByPrefix("prefix_key"); // Retrieve all caches with the specified prefix.
let err = cache.DeleteByPrefix("prefix_key"); // Delete all caches with the specified prefix.
```

### Operating Cache in `RuleContext`
Within the `OnMsg` lifecycle of the rule engine component, the cache object can be obtained through the `RuleContext` object, and cache operations can be performed by calling the corresponding methods.
```go
cache := ctx.ChainCache() // Get the current rule chain cache, operating within the current rule chain namespace.
// cache := ctx.GlobalCache() // Get the global cache, operating within the global namespace.
err := cache.Set("key1", "value1", "0"); // Set cache with no expiration.
err := cache.Set("key2", "value2", "10m"); // Set cache to expire after 10 minutes.
v := cache.Get("key1"); // Retrieve cache.
ok := cache.Has("key1"); // Check if the cache exists.
err := cache.Delete("key1"); // Delete cache.
values := cache.GetByPrefix("prefix_key"); // Retrieve all caches with the specified prefix.
err := cache.DeleteByPrefix("prefix_key"); // Delete all caches with the specified prefix.
```

### Operating Cache in Components
Cache operations can also be performed through components. For reference, see [Cache Get Component](/en/pages/cache_get/), [Cache Delete Component](/en/pages/cache_delete/), and [Cache Set Component](/en/pages/cache_set/).

### Cache Implementation Configuration

By default, RuleGo uses the built-in local memory cache (`utils/cache.MemoryCache`) and provides a global default instance `cache.DefaultCache` (with a default GC cleanup cycle of 5 minutes). If no custom cache implementation is specified through the `types.WithCache` option, the system will automatically use this default memory cache.

To use other cache types (such as Redis, Memcached, etc.), you need to implement the `types.Cache` interface yourself and inject it through the `types.WithCache` option when creating the `Config`.

The `types.Cache` interface is defined as follows:
```go
package types

// Cache defines the interface for cache storage
// Provides key-value based storage and retrieval functionality with expiration support
// Implementation classes must ensure thread safety
type Cache interface {
	// Set stores a key-value pair in cache with optional expiration
	// Parameters:
	//   - key: cache key (string)
	//   - value: value to store (interface{})
	//   - ttl: time-to-live duration string (e.g. "10m", "1h")
	// Returns:
	//   - error: returns error if ttl format is invalid
	// Note: If ttl is 0 or empty string, the item will never expire
	Set(key string, value interface{}, ttl string) error
	// Get retrieves a value from cache by key
	// Parameters:
	//   - key: cache key to lookup (string)
	// Returns:
	//   - interface{}: stored value, nil if not exists or expired
	Get(key string) interface{}
	// Has checks if a key exists in cache
	// Parameters:
	//   - key: cache key to check (string)
	// Returns:
	//   - bool: true if key exists and not expired, false otherwise
	Has(key string) bool
	// Delete removes a cache item by key
	// Parameters:
	//   - key: cache key to delete (string)
	// Returns:
	//   - error: current implementation always returns nil
	Delete(key string) error
	// DeleteByPrefix removes all cache items with the specified prefix
	// Parameters:
	//   - prefix: key prefix to match (string)
	// Returns:
	//   - error: current implementation always returns nil
	DeleteByPrefix(prefix string) error

	// GetByPrefix retrieves all values with keys matching the specified prefix
	// Parameters:
	//   - prefix: key prefix to match (string)
	// Returns:
	//   - map[string]interface{}: map of matching key-value pairs
	GetByPrefix(prefix string) map[string]interface{}
}

```
Configuration example:
```go
// Using a custom cache implementation
config := rulego.NewConfig(types.WithCache(&myCacheImpl{}))

// If using the default in-memory implementation, no explicit configuration is needed. RuleGo will automatically use cache.DefaultCache.
// config := rulego.NewConfig()
```
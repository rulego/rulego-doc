---
title: ç¤ºä¾‹
date: 2024-01-15 10:07:00
permalink: /pages/streamsql/07/
article: false
author: 
  name: StreamSQL
  link: https://github.com/rulego/streamsql
---

# ç¤ºä¾‹é›†åˆ

æœ¬ç« æä¾›StreamSQLçš„å„ç§ä½¿ç”¨ç¤ºä¾‹ï¼Œæ¶µç›–å¸¸è§çš„æµå¤„ç†åœºæ™¯ã€‚æ‰€æœ‰ç¤ºä¾‹éƒ½åŸºäºå®é™…çš„æºç é¡¹ç›®ï¼Œç¡®ä¿å¯è¿è¡Œæ€§ã€?

## ğŸ“ ç¤ºä¾‹ç›®å½•ç»“æ„

StreamSQLé¡¹ç›®æä¾›äº†ä¸°å¯Œçš„ç¤ºä¾‹ï¼Œä½äº?`examples/` ç›®å½•ä¸‹ï¼š

```
examples/
â”œâ”€â”€ non-aggregation/          # éèšåˆåœºæ™¯ç¤ºä¾?
â”œâ”€â”€ advanced-functions/       # é«˜çº§è‡ªå®šä¹‰å‡½æ•°ç¤ºä¾?
â”œâ”€â”€ complex-nested-access/    # å¤æ‚åµŒå¥—å­—æ®µè®¿é—®
â”œâ”€â”€ custom-functions-demo/    # è‡ªå®šä¹‰å‡½æ•°æ¼”ç¤?
â”œâ”€â”€ function-integration-demo/ # å‡½æ•°é›†æˆæ¼”ç¤º
â”œâ”€â”€ nested-field-examples/    # åµŒå¥—å­—æ®µç¤ºä¾‹
â”œâ”€â”€ null-comparison-examples/ # ç©ºå€¼æ¯”è¾ƒç¤ºä¾?
â”œâ”€â”€ overflow_strategy/        # æº¢å‡ºç­–ç•¥ç¤ºä¾‹
â”œâ”€â”€ persistence/              # æŒä¹…åŒ–ç¤ºä¾?
â””â”€â”€ simple-custom-functions/  # ç®€å•è‡ªå®šä¹‰å‡½æ•°
```

## ğŸ“‹ ç¤ºä¾‹åˆ†ç±»

### ğŸš€ å¿«é€Ÿå¼€å§‹ç¤ºä¾?
- [éèšåˆåœºæ™¯](#éèšåˆåœºæ™? - å®æ—¶æ•°æ®è½¬æ¢ã€è¿‡æ»¤ã€æ¸…æ´?
- [èšåˆåˆ†æ](#èšåˆåˆ†æ) - çª—å£åŒ–ç»Ÿè®¡åˆ†æ?
- [åµŒå¥—å­—æ®µå¤„ç†](#åµŒå¥—å­—æ®µå¤„ç†) - å¤æ‚JSONæ•°æ®å¤„ç†

### ğŸ”§ é«˜çº§åŠŸèƒ½ç¤ºä¾‹
- [è‡ªå®šä¹‰å‡½æ•°](#è‡ªå®šä¹‰å‡½æ•? - æ‰©å±•å‡½æ•°åŠŸèƒ½
- [æŒä¹…åŒ–é…ç½®](#æŒä¹…åŒ–é…ç½? - æ•°æ®æŒä¹…åŒ–ç­–ç•?
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–) - é«˜æ€§èƒ½å¤„ç†æŠ€å·?

### ğŸ’¼ ä¸šåŠ¡åœºæ™¯ç¤ºä¾‹
- [IoTè®¾å¤‡ç›‘æ§](#iotè®¾å¤‡ç›‘æ§) - ç‰©è”ç½‘æ•°æ®å¤„ç?
- [å®æ—¶å‘Šè­¦](#å®æ—¶å‘Šè­¦) - å¼‚å¸¸æ£€æµ‹å’Œå‘Šè­¦
- [æ•°æ®è·¯ç”±](#æ•°æ®è·¯ç”±) - æ¡ä»¶è·¯ç”±å’Œåˆ†å?

## éèšåˆåœºæ™?

éèšåˆåœºæ™¯é€‚ç”¨äºå®æ—¶æ•°æ®è½¬æ¢ã€è¿‡æ»¤ã€æ¸…æ´—ç­‰æ“ä½œï¼Œæ¯æ¡æ•°æ®ç«‹å³å¤„ç†è¾“å‡ºï¼Œæ— éœ€ç­‰å¾…çª—å£ã€?

### 1. å®æ—¶æ•°æ®æ¸…æ´—å’Œæ ‡å‡†åŒ–

**åœºæ™¯æè¿°**: å¯¹è¾“å…¥çš„è„æ•°æ®è¿›è¡Œæ¸…æ´—å’Œæ ‡å‡†åŒ–å¤„ç?

```go
package main

import (
    "fmt"
    "github.com/rulego/streamsql"
)

func main() {
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // æ•°æ®æ¸…æ´—ï¼šç©ºå€¼å¤„ç†ã€å­—ç¬¦ä¸²è§„èŒƒåŒ–ã€æ•°å€¼ç²¾åº¦å¤„ç?
    sql := `SELECT 
                deviceId,
                UPPER(TRIM(COALESCE(deviceName, 'UNKNOWN'))) as deviceName,
                ROUND(temperature, 2) as temperature,
                ROUND(humidity, 1) as humidity,
                CASE 
                    WHEN status = '1' THEN 'ONLINE'
                    WHEN status = '0' THEN 'OFFLINE'
                    ELSE 'UNKNOWN'
                END as status
            FROM stream
            WHERE temperature IS NOT NULL AND humidity IS NOT NULL`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("æ¸…æ´—åæ•°æ? %v\n", result)
    })
    
    // å‘é€è„æ•°æ®
    dirtyData := []map[string]interface{}{
        {"deviceId": "T001", "deviceName": "  sensor_01  ", "temperature": 25.567, "humidity": 60.12, "status": "1"},
        {"deviceId": "T002", "deviceName": nil, "temperature": 45.891, "humidity": 40.0, "status": "0"},
        {"deviceId": "T003", "deviceName": "sensor_03", "temperature": nil, "humidity": 30.0, "status": "unknown"},
    }
    
    for _, data := range dirtyData {
        ssql.AddData(data)
    }
}
```

### 2. æ•°æ®èšåˆç»Ÿè®¡

```go
package main

import (
    "fmt"
    "math/rand"
    "time"
    "github.com/rulego/streamsql"
)

func main() {
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // æ¯åˆ†é’Ÿç»Ÿè®¡å„åŒºåŸŸçš„å¹³å‡æ¸©æ¹¿åº¦
    sql := `SELECT location,
                   COUNT(*) as sample_count,
                   AVG(temperature) as avg_temperature,
                   AVG(humidity) as avg_humidity,
                   MIN(temperature) as min_temperature,
                   MAX(temperature) as max_temperature,
                   window_start() as window_start
            FROM stream
            GROUP BY location, TumblingWindow('1m')`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("åŒºåŸŸç»Ÿè®¡: %v\n", result)
    })
    
    // æ¨¡æ‹Ÿæ•°æ®å‘é€?
    locations := []string{"åŒ—äº¬", "ä¸Šæµ·", "å¹¿å·", "æ·±åœ³"}
    go func() {
        for i := 0; i < 100; i++ {
            data := map[string]interface{}{
                "deviceId":    fmt.Sprintf("sensor_%d", rand.Intn(10)),
                "location":    locations[rand.Intn(len(locations))],
                "temperature": 15.0 + rand.Float64()*20,
                "humidity":    30.0 + rand.Float64()*40,
                "timestamp":   time.Now(),
            }
            ssql.AddData(data)
            time.Sleep(500 * time.Millisecond)
        }
    }()
    
    time.Sleep(3 * time.Minute)
}
```

## æ•°æ®åˆå¹¶

### 1. å•æµå¤šè®¾å¤‡æ•°æ®åˆå¹?

åœ¨ç‰©è”ç½‘åœºæ™¯ä¸­ï¼Œå¤šä¸ªä¼ æ„Ÿå™¨çš„æ•°æ®å¾€å¾€æ··æ‚åœ¨ä¸€ä¸ªæ•°æ®æµä¸­ï¼Œæ¯ä¸ªä¼ æ„Ÿå™¨çš„é‡‡é›†é¢‘ç‡ä¸åŒï¼Œæ•°æ®è¾ƒä¸ºç¢ç‰‡åŒ–ã€‚æˆ‘ä»¬éœ€è¦å°†ç›¸å…³ä¼ æ„Ÿå™¨çš„æ•°æ®åˆå¹¶ï¼Œä»¥ä¾¿åç»­åˆ†æã€?

```go
package main

import (
    "fmt"
    "math/rand"
    "time"
    "github.com/rulego/streamsql"
    "github.com/rulego/streamsql/functions"
)

func main() {
    // æ³¨å†Œæœ€æ–°å€¼è·å–å‡½æ•?
    functions.RegisterCustomFunction("latest_value", functions.TypeAnalytical,
        "æ•°æ®åˆå¹¶", "è·å–æŒ‡å®šå­—æ®µçš„æœ€æ–°éç©ºå€?, 2, 2,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            fieldName, _ := functions.ConvertToString(args[0])
            defaultValue := args[1]
            
            // ä»ä¸Šä¸‹æ–‡è·å–å†å²æ•°æ®ï¼ˆç®€åŒ–å®ç°ï¼‰
            if ctx.CustomData == nil {
                ctx.CustomData = make(map[string]interface{})
            }
            
            if ctx.CurrentRow != nil {
                if value, exists := ctx.CurrentRow[fieldName]; exists && value != nil {
                    ctx.CustomData[fieldName] = value
                    return value, nil
                }
            }
            
            // è¿”å›å†å²å€¼æˆ–é»˜è®¤å€?
            if value, exists := ctx.CustomData[fieldName]; exists {
                return value, nil
            }
            
            return defaultValue, nil
        })
    defer functions.Unregister("latest_value")
    
    ssql := streamsql.New()
    defer ssql.Stop()
    
    fmt.Println("=== æ–¹æ¡ˆ1: ä½¿ç”¨LATESTå‡½æ•°åˆå¹¶æœ€æ–°æ•°æ?===")
    
    // æ–¹æ¡ˆ1ï¼šæ¯å½“æ”¶åˆ°æ¸©åº¦æ•°æ®æ—¶ï¼Œç»„åˆæœ€æ–°çš„æ¸©æ¹¿åº¦æ•°æ?
    sql1 := `SELECT device_id,
                    latest_value('temperature', temperature) as temperature,
                    latest_value('humidity', humidity) as humidity,
                    timestamp
             FROM stream
             WHERE temperature IS NOT NULL`
    
    err := ssql.Execute(sql1)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("åˆå¹¶ç»“æœ1: %v\n", result)
    })
    
    go simulateMixedSensorData(ssql, "æ–¹æ¡ˆ1")
    time.Sleep(30 * time.Second)
    
    ssql.Stop()
    
    fmt.Println("\n=== æ–¹æ¡ˆ2: æŒ‰æ•°æ®ç±»å‹åˆ†ç»„åˆå¹?===")
    
    // é‡æ–°åˆ›å»ºå®ä¾‹
    ssql2 := streamsql.New()
    defer ssql2.Stop()
    
    // æ–¹æ¡ˆ2ï¼šæŒ‰è®¾å¤‡ç±»å‹åˆ†ç»„ï¼Œå®šæœŸè¾“å‡ºå®Œæ•´æ•°æ?
    sql2 := `SELECT device_id,
                    AVG(CASE WHEN sensor_type = 'temperature' THEN value END) as temperature,
                    AVG(CASE WHEN sensor_type = 'humidity' THEN value END) as humidity,
                    COUNT(*) as sample_count,
                    window_start() as window_start
             FROM stream
             WHERE value IS NOT NULL
             GROUP BY device_id, TumblingWindow('10s')
             HAVING temperature IS NOT NULL AND humidity IS NOT NULL`
    
    err = ssql2.Execute(sql2)
    if err != nil {
        panic(err)
    }
    
    ssql2.Stream().AddSink(func(result interface{}) {
        fmt.Printf("åˆå¹¶ç»“æœ2: %v\n", result)
    })
    
    go simulateTypedSensorData(ssql2, "æ–¹æ¡ˆ2")
    time.Sleep(30 * time.Second)
    
    ssql2.Stop()
    
    fmt.Println("\n=== æ–¹æ¡ˆ3: æ—¶é—´ç›¸è¿‘æ•°æ®åˆå¹¶ ===")
    
    // æ–¹æ¡ˆ3ï¼šåŸºäºæ—¶é—´é—´éš”åˆå¹?
    ssql3 := streamsql.New()
    defer ssql3.Stop()
    
    sql3 := `SELECT device_id,
                    AVG(temperature) as avg_temperature,
                    AVG(humidity) as avg_humidity,
                    COUNT(*) as data_points,
                    MIN(timestamp) as period_start,
                    MAX(timestamp) as period_end
             FROM stream
             WHERE temperature IS NOT NULL OR humidity IS NOT NULL
             GROUP BY device_id, TumblingWindow('5s')`
    
    err = ssql3.Execute(sql3)
    if err != nil {
        panic(err)
    }
    
    ssql3.Stream().AddSink(func(result interface{}) {
        fmt.Printf("åˆå¹¶ç»“æœ3: %v\n", result)
    })
    
    go simulateTimeBasedData(ssql3, "æ–¹æ¡ˆ3")
    time.Sleep(20 * time.Second)
}

// æ¨¡æ‹Ÿæ··åˆä¼ æ„Ÿå™¨æ•°æ®ï¼ˆæ–¹æ¡ˆ1ï¼?
func simulateMixedSensorData(ssql *streamsql.StreamSQL, scenario string) {
    devices := []string{"device_A", "device_B"}
    
    for i := 0; i < 20; i++ {
        for _, device := range devices {
            // æ¸©åº¦æ•°æ®ï¼ˆé¢‘ç‡é«˜ï¼?
            if i%2 == 0 {
                tempData := map[string]interface{}{
                    "device_id":   device,
                    "temperature": 20.0 + rand.Float64()*15,
                    "timestamp":   time.Now(),
                }
                ssql.AddData(tempData)
                fmt.Printf("[%s] å‘é€æ¸©åº¦æ•°æ? %s = %.1fÂ°C\n", 
                    scenario, device, tempData["temperature"])
            }
            
            // æ¹¿åº¦æ•°æ®ï¼ˆé¢‘ç‡ä½ï¼?
            if i%3 == 0 {
                humidData := map[string]interface{}{
                    "device_id": device,
                    "humidity":  40.0 + rand.Float64()*40,
                    "timestamp": time.Now(),
                }
                ssql.AddData(humidData)
                fmt.Printf("[%s] å‘é€æ¹¿åº¦æ•°æ? %s = %.1f%%\n", 
                    scenario, device, humidData["humidity"])
            }
        }
        time.Sleep(1 * time.Second)
    }
}

// æ¨¡æ‹ŸæŒ‰ç±»å‹åˆ†ç»„çš„ä¼ æ„Ÿå™¨æ•°æ®ï¼ˆæ–¹æ¡ˆ2ï¼?
func simulateTypedSensorData(ssql *streamsql.StreamSQL, scenario string) {
    devices := []string{"sensor001", "sensor002"}
    sensorTypes := []string{"temperature", "humidity"}
    
    for i := 0; i < 30; i++ {
        for _, device := range devices {
            for _, sensorType := range sensorTypes {
                var value float64
                if sensorType == "temperature" {
                    value = 18.0 + rand.Float64()*20
                } else {
                    value = 30.0 + rand.Float64()*50
                }
                
                data := map[string]interface{}{
                    "device_id":   device,
                    "sensor_type": sensorType,
                    "value":       value,
                    "timestamp":   time.Now(),
                }
                
                ssql.AddData(data)
                fmt.Printf("[%s] %s %s: %.2f\n", 
                    scenario, device, sensorType, value)
            }
        }
        time.Sleep(800 * time.Millisecond)
    }
}

// æ¨¡æ‹Ÿæ—¶é—´ç›¸å…³çš„æ•°æ®ï¼ˆæ–¹æ¡ˆ3ï¼?
func simulateTimeBasedData(ssql *streamsql.StreamSQL, scenario string) {
    devices := []string{"station_1", "station_2"}
    
    for i := 0; i < 20; i++ {
        for _, device := range devices {
            // éšæœºå‘é€æ¸©åº¦æˆ–æ¹¿åº¦æ•°æ®
            if rand.Float64() < 0.7 {
                data := map[string]interface{}{
                    "device_id":   device,
                    "temperature": 22.0 + rand.Float64()*8,
                    "timestamp":   time.Now(),
                }
                ssql.AddData(data)
                fmt.Printf("[%s] %s æ¸©åº¦: %.1fÂ°C\n", 
                    scenario, device, data["temperature"])
            }
            
            if rand.Float64() < 0.5 {
                data := map[string]interface{}{
                    "device_id": device,
                    "humidity":  45.0 + rand.Float64()*30,
                    "timestamp": time.Now(),
                }
                ssql.AddData(data)
                fmt.Printf("[%s] %s æ¹¿åº¦: %.1f%%\n", 
                    scenario, device, data["humidity"])
            }
        }
        time.Sleep(1 * time.Second)
    }
}

## IoTè®¾å¤‡ç›‘æ§

### 1. è®¾å¤‡å¥åº·çŠ¶æ€ç›‘æ?

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
    "github.com/rulego/streamsql/functions"
)

func main() {
    // æ³¨å†Œè®¾å¤‡å¥åº·è¯„ä¼°å‡½æ•°
    functions.RegisterCustomFunction("health_score", functions.TypeAnalytical,
        "è®¾å¤‡ç›‘æ§", "è®¡ç®—è®¾å¤‡å¥åº·è¯„åˆ†", 4, 4,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            temperature, _ := functions.ConvertToFloat64(args[0])
            voltage, _ := functions.ConvertToFloat64(args[1])
            signalStrength, _ := functions.ConvertToFloat64(args[2])
            errorRate, _ := functions.ConvertToFloat64(args[3])
            
            score := 100.0
            var alerts []string
            
            // æ¸©åº¦è¯„ä¼°
            if temperature > 70 {
                score -= 30
                alerts = append(alerts, "é«˜æ¸©")
            } else if temperature < -20 {
                score -= 25
                alerts = append(alerts, "ä½æ¸©")
            }
            
            // ç”µå‹è¯„ä¼°
            if voltage < 3.0 {
                score -= 35
                alerts = append(alerts, "ç”µå‹ä¸è¶³")
            }
            
            // ä¿¡å·å¼ºåº¦è¯„ä¼°
            if signalStrength < -80 {
                score -= 20
                alerts = append(alerts, "ä¿¡å·å¼?)
            }
            
            // é”™è¯¯ç‡è¯„ä¼?
            if errorRate > 0.1 {
                score -= 30
                alerts = append(alerts, "é”™è¯¯ç‡é«˜")
            }
            
            return map[string]interface{}{
                "score":  score,
                "alerts": alerts,
                "status": getHealthStatus(score),
            }, nil
        })
    defer functions.Unregister("health_score")
    
    ssql := streamsql.New()
    defer ssql.Stop()
    
    sql := `SELECT deviceId,
                   health_score(temperature, voltage, signal_strength, error_rate) as health,
                   AVG(temperature) as avg_temp,
                   COUNT(*) as message_count,
                   window_start() as check_time
            FROM stream
            GROUP BY deviceId, TumblingWindow('5m')
            HAVING JSON_EXTRACT(health, '$.score') < 80`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("è®¾å¤‡å¥åº·å‘Šè­¦: %v\n", result)
    })
    
    // æ¨¡æ‹Ÿè®¾å¤‡æ•°æ®
    go simulateDeviceData(ssql)
    
    time.Sleep(10 * time.Minute)
}

func getHealthStatus(score float64) string {
    if score >= 90 {
        return "ä¼˜ç§€"
    } else if score >= 70 {
        return "è‰¯å¥½"
    } else if score >= 50 {
        return "ä¸€èˆ?
    } else {
        return "æ•…éšœ"
    }
}

func simulateDeviceData(ssql *streamsql.StreamSQL) {
    devices := []string{"device001", "device002", "device003", "device004"}
    
    for {
        for _, device := range devices {
            // æ¨¡æ‹Ÿä¸åŒçš„è®¾å¤‡çŠ¶æ€?
            var temp, voltage, signal, errorRate float64
            
            if device == "device002" {
                // æ¨¡æ‹Ÿæ•…éšœè®¾å¤‡
                temp = 75 + rand.Float64()*10      // é«˜æ¸©
                voltage = 2.5 + rand.Float64()*0.4 // ä½ç”µå?
                signal = -85 - rand.Float64()*10   // å¼±ä¿¡å?
                errorRate = 0.15 + rand.Float64()*0.1
            } else {
                // æ­£å¸¸è®¾å¤‡
                temp = 20 + rand.Float64()*30
                voltage = 3.3 + rand.Float64()*0.7
                signal = -40 - rand.Float64()*30
                errorRate = rand.Float64() * 0.05
            }
            
            data := map[string]interface{}{
                "deviceId":        device,
                "temperature":     temp,
                "voltage":         voltage,
                "signal_strength": signal,
                "error_rate":      errorRate,
                "timestamp":       time.Now(),
            }
            
            ssql.AddData(data)
        }
        
        time.Sleep(10 * time.Second)
    }
}
```

### 2. è®¾å¤‡è¿æ¥çŠ¶æ€ç›‘æ?

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
)

func main() {
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // ä½¿ç”¨ä¼šè¯çª—å£ç›‘æ§è®¾å¤‡è¿æ¥çŠ¶æ€?
    // å¦‚æœ5åˆ†é’Ÿæ²¡æœ‰å¿ƒè·³ï¼Œè®¤ä¸ºè®¾å¤‡ç¦»çº?
    sql := `SELECT deviceId,
                   COUNT(*) as heartbeat_count,
                   MIN(timestamp) as session_start,
                   MAX(timestamp) as last_heartbeat,
                   AVG(battery_level) as avg_battery,
                   AVG(signal_strength) as avg_signal
            FROM stream
            WHERE message_type = 'heartbeat'
            GROUP BY deviceId, SessionWindow('5m')
            HAVING heartbeat_count < 5`  // 5åˆ†é’Ÿå†…å¿ƒè·³å°‘äº?æ¬¡å‘Šè­?
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("è®¾å¤‡è¿æ¥å¼‚å¸¸: %v\n", result)
    })
    
    // æ¨¡æ‹Ÿè®¾å¤‡å¿ƒè·³
    go func() {
        devices := map[string]bool{
            "device_A": true,  // æ­£å¸¸è®¾å¤‡
            "device_B": true,  // æ­£å¸¸è®¾å¤‡
            "device_C": false, // å¼‚å¸¸è®¾å¤‡ï¼Œå¿ƒè·³ä¸ç¨³å®š
        }
        
        for {
            for deviceId, isHealthy := range devices {
                // æ­£å¸¸è®¾å¤‡æ¯?0ç§’å‘é€å¿ƒè·?
                // å¼‚å¸¸è®¾å¤‡éšæœºå‘é€?
                if isHealthy || rand.Float64() < 0.3 {
                    data := map[string]interface{}{
                        "deviceId":        deviceId,
                        "message_type":    "heartbeat",
                        "battery_level":   20 + rand.Float64()*80,
                        "signal_strength": -30 - rand.Float64()*50,
                        "timestamp":       time.Now(),
                    }
                    ssql.AddData(data)
                }
            }
            time.Sleep(30 * time.Second)
        }
    }()
    
    time.Sleep(20 * time.Minute)
}
```

## å®æ—¶æ•°æ®åˆ†æ

### 1. è‚¡ç¥¨ä»·æ ¼ç›‘æ§

```go
package main

import (
    "fmt"
    "math/rand"
    "time"
    "github.com/rulego/streamsql"
    "github.com/rulego/streamsql/functions"
)

func main() {
    // æ³¨å†Œç§»åŠ¨å¹³å‡çº¿è®¡ç®—å‡½æ•?
    functions.RegisterCustomFunction("moving_average", functions.TypeAnalytical,
        "æŠ€æœ¯åˆ†æ?, "è®¡ç®—ç§»åŠ¨å¹³å‡çº?, 2, 2,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            prices, err := functions.ConvertToFloat64Array(args[0])
            if err != nil {
                return nil, err
            }
            
            period, err := functions.ConvertToInt(args[1])
            if err != nil {
                return nil, err
            }
            
            if len(prices) < period {
                return nil, fmt.Errorf("æ•°æ®ä¸è¶³")
            }
            
            sum := 0.0
            for i := len(prices) - period; i < len(prices); i++ {
                sum += prices[i]
            }
            
            return sum / float64(period), nil
        })
    defer functions.Unregister("moving_average")
    
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // è®¡ç®—5åˆ†é’Ÿç§»åŠ¨å¹³å‡çº¿å’Œä»·æ ¼å˜åŒ–
    sql := `SELECT symbol,
                   AVG(price) as avg_price,
                   MIN(price) as min_price,
                   MAX(price) as max_price,
                   COUNT(*) as trade_count,
                   SUM(volume) as total_volume,
                   STDDEV(price) as price_volatility,
                   (MAX(price) - MIN(price)) / MIN(price) * 100 as price_change_pct,
                   window_start() as period_start
            FROM stream
            WHERE price > 0 AND volume > 0
            GROUP BY symbol, TumblingWindow('5m')
            HAVING price_volatility > 1.0 OR price_change_pct > 5.0`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("è‚¡ä»·å¼‚åŠ¨: %v\n", result)
    })
    
    // æ¨¡æ‹Ÿè‚¡ç¥¨äº¤æ˜“æ•°æ®
    go func() {
        symbols := []string{"AAPL", "GOOGL", "MSFT", "TSLA", "AMZN"}
        basePrices := map[string]float64{
            "AAPL":  150.0,
            "GOOGL": 2800.0,
            "MSFT":  300.0,
            "TSLA":  800.0,
            "AMZN":  3200.0,
        }
        
        for {
            for _, symbol := range symbols {
                basePrice := basePrices[symbol]
                // æ¨¡æ‹Ÿä»·æ ¼æ³¢åŠ¨
                change := (rand.Float64() - 0.5) * 0.02 // Â±1%çš„éšæœºæ³¢åŠ?
                price := basePrice * (1 + change)
                
                data := map[string]interface{}{
                    "symbol":    symbol,
                    "price":     price,
                    "volume":    rand.Intn(10000) + 1000,
                    "timestamp": time.Now(),
                }
                
                ssql.AddData(data)
                basePrices[symbol] = price // æ›´æ–°åŸºå‡†ä»·æ ¼
            }
            
            time.Sleep(1 * time.Second)
        }
    }()
    
    time.Sleep(30 * time.Minute)
}
```

### 2. ç½‘ç»œæµé‡åˆ†æ

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
)

func main() {
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // ç½‘ç»œæµé‡å¼‚å¸¸æ£€æµ?
    sql := `SELECT source_ip,
                   dest_ip,
                   protocol,
                   COUNT(*) as packet_count,
                   SUM(bytes) as total_bytes,
                   AVG(bytes) as avg_packet_size,
                   COUNT(DISTINCT dest_port) as unique_ports,
                   window_start() as time_window
            FROM stream
            WHERE bytes > 0
            GROUP BY source_ip, dest_ip, protocol, TumblingWindow('1m')
            HAVING packet_count > 1000 OR total_bytes > 10485760 OR unique_ports > 10`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("ç½‘ç»œå¼‚å¸¸æ£€æµ? %v\n", result)
    })
    
    // æ¨¡æ‹Ÿç½‘ç»œæ•°æ®åŒ?
    go func() {
        protocols := []string{"TCP", "UDP", "ICMP"}
        ips := []string{"192.168.1.100", "192.168.1.101", "10.0.0.50", "172.16.0.10"}
        
        for {
            data := map[string]interface{}{
                "source_ip":   ips[rand.Intn(len(ips))],
                "dest_ip":     ips[rand.Intn(len(ips))],
                "protocol":    protocols[rand.Intn(len(protocols))],
                "dest_port":   1000 + rand.Intn(8000),
                "bytes":       64 + rand.Intn(1436),
                "timestamp":   time.Now(),
            }
            
            ssql.AddData(data)
            time.Sleep(10 * time.Millisecond)
        }
    }()
    
    time.Sleep(10 * time.Minute)
}
```

## ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§

### 1. ç”µå•†å®æ—¶è®¢å•åˆ†æ

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
)

func main() {
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // å®æ—¶è®¢å•åˆ†æï¼šæ¯å°æ—¶ç»Ÿè®¡
    sql := `SELECT category,
                   COUNT(*) as order_count,
                   SUM(amount) as total_revenue,
                   AVG(amount) as avg_order_value,
                   COUNT(DISTINCT customer_id) as unique_customers,
                   SUM(quantity) as total_items,
                   window_start() as hour_start
            FROM stream
            WHERE order_status = 'completed' AND amount > 0
            GROUP BY category, TumblingWindow('1h')
            ORDER BY total_revenue DESC`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("å°æ—¶é”€å”®æŠ¥å‘? %v\n", result)
    })
    
    // æ¨¡æ‹Ÿè®¢å•æ•°æ®
    go func() {
        categories := []string{"electronics", "clothing", "books", "home", "sports"}
        statuses := []string{"pending", "completed", "cancelled"}
        
        for {
            data := map[string]interface{}{
                "order_id":     fmt.Sprintf("ORD_%d", time.Now().UnixNano()),
                "customer_id":  fmt.Sprintf("CUST_%d", rand.Intn(1000)),
                "category":     categories[rand.Intn(len(categories))],
                "amount":       10.0 + rand.Float64()*490.0,
                "quantity":     1 + rand.Intn(5),
                "order_status": statuses[rand.Intn(len(statuses))],
                "timestamp":    time.Now(),
            }
            
            ssql.AddData(data)
            time.Sleep(2 * time.Second)
        }
    }()
    
    time.Sleep(3 * time.Hour)
}
```

### 2. APIæ€§èƒ½ç›‘æ§

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
)

func main() {
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // APIæ€§èƒ½ç›‘æ§ï¼šæ¯5åˆ†é’Ÿç»Ÿè®¡
    sql := `SELECT endpoint,
                   method,
                   COUNT(*) as request_count,
                   AVG(response_time) as avg_response_time,
                   PERCENTILE(response_time, 0.95) as p95_response_time,
                   PERCENTILE(response_time, 0.99) as p99_response_time,
                   SUM(CASE WHEN status_code >= 400 THEN 1 ELSE 0 END) as error_count,
                   SUM(CASE WHEN response_time > 1000 THEN 1 ELSE 0 END) as slow_requests,
                   window_start() as period_start
            FROM stream
            WHERE response_time > 0
            GROUP BY endpoint, method, TumblingWindow('5m')
            HAVING error_count > 10 OR avg_response_time > 500 OR p95_response_time > 1000`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("APIæ€§èƒ½å‘Šè­¦: %v\n", result)
    })
    
    // æ¨¡æ‹ŸAPIè¯·æ±‚æ—¥å¿—
    go func() {
        endpoints := []string{"/api/users", "/api/orders", "/api/products", "/api/payments"}
        methods := []string{"GET", "POST", "PUT", "DELETE"}
        
        for {
            endpoint := endpoints[rand.Intn(len(endpoints))]
            method := methods[rand.Intn(len(methods))]
            
            // æ¨¡æ‹Ÿä¸åŒçš„å“åº”æ—¶é—?
            var responseTime int
            var statusCode int
            
            if endpoint == "/api/payments" && rand.Float64() < 0.1 {
                // æ”¯ä»˜æ¥å£å¶å°”å¾ˆæ…¢
                responseTime = 2000 + rand.Intn(3000)
                statusCode = 200
            } else if rand.Float64() < 0.05 {
                // 5%çš„é”™è¯¯ç‡
                responseTime = 100 + rand.Intn(500)
                statusCode = 400 + rand.Intn(200)
            } else {
                // æ­£å¸¸è¯·æ±‚
                responseTime = 50 + rand.Intn(300)
                statusCode = 200
            }
            
            data := map[string]interface{}{
                "endpoint":      endpoint,
                "method":        method,
                "status_code":   statusCode,
                "response_time": responseTime,
                "user_id":       fmt.Sprintf("user_%d", rand.Intn(100)),
                "timestamp":     time.Now(),
            }
            
            ssql.AddData(data)
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    time.Sleep(1 * time.Hour)
}
```

## å¼‚å¸¸æ£€æµ?

### 1. åŸºäºç»Ÿè®¡çš„å¼‚å¸¸æ£€æµ?

```go
package main

import (
    "fmt"
    "math"
    "time"
    "github.com/rulego/streamsql"
    "github.com/rulego/streamsql/functions"
)

func main() {
    // æ³¨å†ŒZ-Scoreå¼‚å¸¸æ£€æµ‹å‡½æ•?
    functions.RegisterCustomFunction("z_score_anomaly", functions.TypeAnalytical,
        "å¼‚å¸¸æ£€æµ?, "åŸºäºZ-Scoreçš„å¼‚å¸¸æ£€æµ?, 3, 4,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            value, _ := functions.ConvertToFloat64(args[0])
            mean, _ := functions.ConvertToFloat64(args[1])
            stddev, _ := functions.ConvertToFloat64(args[2])
            
            threshold := 3.0 // é»˜è®¤é˜ˆå€?
            if len(args) > 3 {
                threshold, _ = functions.ConvertToFloat64(args[3])
            }
            
            if stddev == 0 {
                return map[string]interface{}{
                    "is_anomaly": false,
                    "z_score":    0.0,
                    "severity":   "normal",
                }, nil
            }
            
            zScore := math.Abs(value-mean) / stddev
            isAnomaly := zScore > threshold
            
            var severity string
            if zScore > 4 {
                severity = "critical"
            } else if zScore > 3 {
                severity = "high"
            } else if zScore > 2 {
                severity = "medium"
            } else {
                severity = "normal"
            }
            
            return map[string]interface{}{
                "is_anomaly": isAnomaly,
                "z_score":    zScore,
                "severity":   severity,
                "threshold":  threshold,
            }, nil
        })
    defer functions.Unregister("z_score_anomaly")
    
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // å¼‚å¸¸æ£€æµ‹ï¼šä½¿ç”¨æ»‘åŠ¨çª—å£è¿›è¡Œå®æ—¶æ£€æµ?
    sql := `SELECT deviceId,
                   temperature,
                   AVG(temperature) as rolling_mean,
                   STDDEV(temperature) as rolling_stddev,
                   z_score_anomaly(temperature, AVG(temperature), STDDEV(temperature), 2.5) as anomaly_info,
                   COUNT(*) as window_size,
                   window_start() as detection_time
            FROM stream
            WHERE temperature IS NOT NULL
            GROUP BY deviceId, SlidingWindow('10m', '1m')
            HAVING JSON_EXTRACT(anomaly_info, '$.is_anomaly') = true`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("å¼‚å¸¸æ£€æµ‹å‘Šè­? %v\n", result)
    })
    
    // æ¨¡æ‹Ÿä¼ æ„Ÿå™¨æ•°æ®ï¼ŒåŒ…å«å¼‚å¸¸å€?
    go func() {
        devices := []string{"sensor_01", "sensor_02", "sensor_03"}
        baseTemp := 25.0
        
        for {
            for _, device := range devices {
                var temperature float64
                
                if rand.Float64() < 0.05 { // 5%æ¦‚ç‡äº§ç”Ÿå¼‚å¸¸å€?
                    if rand.Float64() < 0.5 {
                        temperature = baseTemp + 20 + rand.Float64()*10 // é«˜æ¸©å¼‚å¸¸
                    } else {
                        temperature = baseTemp - 20 - rand.Float64()*10 // ä½æ¸©å¼‚å¸¸
                    }
                } else {
                    // æ­£å¸¸æ•°æ®ï¼šåŸºå‡†æ¸©åº?Â± 5åº¦å†…çš„æ­£æ€åˆ†å¸?
                    temperature = baseTemp + (rand.NormFloat64() * 2)
                }
                
                data := map[string]interface{}{
                    "deviceId":    device,
                    "temperature": temperature,
                    "timestamp":   time.Now(),
                }
                
                ssql.AddData(data)
            }
            
            time.Sleep(5 * time.Second)
        }
    }()
    
    time.Sleep(30 * time.Minute)
}
```

### 2. å¤šç»´åº¦å¼‚å¸¸æ£€æµ?

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
    "github.com/rulego/streamsql/functions"
)

func main() {
    // æ³¨å†Œå¤šç»´åº¦å¼‚å¸¸æ£€æµ‹å‡½æ•?
    functions.RegisterCustomFunction("multi_dim_anomaly", functions.TypeAnalytical,
        "å¼‚å¸¸æ£€æµ?, "å¤šç»´åº¦å¼‚å¸¸æ£€æµ?, 6, 6,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            // å½“å‰å€?
            temp, _ := functions.ConvertToFloat64(args[0])
            humid, _ := functions.ConvertToFloat64(args[1])
            pressure, _ := functions.ConvertToFloat64(args[2])
            
            // å†å²å¹³å‡å€?
            tempMean, _ := functions.ConvertToFloat64(args[3])
            humidMean, _ := functions.ConvertToFloat64(args[4])
            pressureMean, _ := functions.ConvertToFloat64(args[5])
            
            var anomalies []string
            score := 0.0
            
            // æ¸©åº¦æ£€æŸ?
            tempDiff := math.Abs(temp - tempMean)
            if tempDiff > 10 {
                anomalies = append(anomalies, "temperature")
                score += tempDiff / 10
            }
            
            // æ¹¿åº¦æ£€æŸ?
            humidDiff := math.Abs(humid - humidMean)
            if humidDiff > 20 {
                anomalies = append(anomalies, "humidity")
                score += humidDiff / 20
            }
            
            // æ°”å‹æ£€æŸ?
            pressureDiff := math.Abs(pressure - pressureMean)
            if pressureDiff > 50 {
                anomalies = append(anomalies, "pressure")
                score += pressureDiff / 50
            }
            
            return map[string]interface{}{
                "is_anomaly":        len(anomalies) > 0,
                "anomaly_fields":    anomalies,
                "anomaly_score":     score,
                "temp_deviation":    tempDiff,
                "humid_deviation":   humidDiff,
                "pressure_deviation": pressureDiff,
            }, nil
        })
    defer functions.Unregister("multi_dim_anomaly")
    
    ssql := streamsql.New()
    defer ssql.Stop()
    
    sql := `SELECT station_id,
                   temperature,
                   humidity,
                   pressure,
                   AVG(temperature) as temp_baseline,
                   AVG(humidity) as humid_baseline,
                   AVG(pressure) as pressure_baseline,
                   multi_dim_anomaly(
                       temperature, humidity, pressure,
                       AVG(temperature), AVG(humidity), AVG(pressure)
                   ) as anomaly_result,
                   window_start() as check_time
            FROM stream
            GROUP BY station_id, SlidingWindow('20m', '5m')
            HAVING JSON_EXTRACT(anomaly_result, '$.is_anomaly') = true`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("å¤šç»´åº¦å¼‚å¸? %v\n", result)
    })
    
    // æ¨¡æ‹Ÿæ°”è±¡ç«™æ•°æ?
    go simulateWeatherData(ssql)
    
    time.Sleep(2 * time.Hour)
}

func simulateWeatherData(ssql *streamsql.StreamSQL) {
    stations := []string{"station_A", "station_B", "station_C"}
    
    for {
        for _, station := range stations {
            // åŸºç¡€å€?
            baseTemp := 20.0
            baseHumid := 60.0
            basePressure := 1013.25
            
            var temp, humid, pressure float64
            
            if station == "station_B" && rand.Float64() < 0.1 {
                // station_B æœ?0%æ¦‚ç‡äº§ç”Ÿå¼‚å¸¸
                temp = baseTemp + (rand.Float64()-0.5)*30    // å¤§å¹…æ³¢åŠ¨
                humid = baseHumid + (rand.Float64()-0.5)*60  // å¤§å¹…æ³¢åŠ¨
                pressure = basePressure + (rand.Float64()-0.5)*200
            } else {
                // æ­£å¸¸æ•°æ®
                temp = baseTemp + (rand.Float64()-0.5)*10
                humid = baseHumid + (rand.Float64()-0.5)*20
                pressure = basePressure + (rand.Float64()-0.5)*50
            }
            
            data := map[string]interface{}{
                "station_id": station,
                "temperature": temp,
                "humidity":    humid,
                "pressure":    pressure,
                "timestamp":   time.Now(),
            }
            
            ssql.AddData(data)
        }
        
        time.Sleep(30 * time.Second)
    }
}
```

## è‡ªå®šä¹‰å‡½æ•°åº”ç”?

### 1. åœ°ç†ä½ç½®è®¡ç®—

```go
package main

import (
    "fmt"
    "math"
    "time"
    "github.com/rulego/streamsql"
    "github.com/rulego/streamsql/functions"
)

func main() {
    // æ³¨å†Œåœ°ç†è·ç¦»è®¡ç®—å‡½æ•°
    functions.RegisterCustomFunction("geo_distance", functions.TypeMath,
        "åœ°ç†è®¡ç®—", "è®¡ç®—ä¸¤ç‚¹é—´çš„åœ°ç†è·ç¦»(å…¬é‡Œ)", 4, 4,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            lat1, _ := functions.ConvertToFloat64(args[0])
            lon1, _ := functions.ConvertToFloat64(args[1])
            lat2, _ := functions.ConvertToFloat64(args[2])
            lon2, _ := functions.ConvertToFloat64(args[3])
            
            // è½¬æ¢ä¸ºå¼§åº?
            lat1Rad := lat1 * math.Pi / 180
            lon1Rad := lon1 * math.Pi / 180
            lat2Rad := lat2 * math.Pi / 180
            lon2Rad := lon2 * math.Pi / 180
            
            // ä½¿ç”¨çƒé¢ä½™å¼¦å®šå¾‹è®¡ç®—è·ç¦»
            deltaLat := lat2Rad - lat1Rad
            deltaLon := lon2Rad - lon1Rad
            
            a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
                math.Cos(lat1Rad)*math.Cos(lat2Rad)*
                math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
            c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
            
            // åœ°çƒåŠå¾„(å…¬é‡Œ)
            radius := 6371.0
            distance := radius * c
            
            return distance, nil
        })
    
    // æ³¨å†ŒåŒºåŸŸåˆ¤æ–­å‡½æ•°
    functions.RegisterCustomFunction("in_region", functions.TypeAnalytical,
        "åœ°ç†åˆ¤æ–­", "åˆ¤æ–­åæ ‡æ˜¯å¦åœ¨æŒ‡å®šåŒºåŸŸå†…", 6, 6,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            lat, _ := functions.ConvertToFloat64(args[0])
            lon, _ := functions.ConvertToFloat64(args[1])
            centerLat, _ := functions.ConvertToFloat64(args[2])
            centerLon, _ := functions.ConvertToFloat64(args[3])
            radius, _ := functions.ConvertToFloat64(args[4]) // å…¬é‡Œ
            regionName, _ := functions.ConvertToString(args[5])
            
            // è®¡ç®—åˆ°ä¸­å¿ƒç‚¹çš„è·ç¦?
            lat1Rad := lat * math.Pi / 180
            lon1Rad := lon * math.Pi / 180
            lat2Rad := centerLat * math.Pi / 180
            lon2Rad := centerLon * math.Pi / 180
            
            deltaLat := lat2Rad - lat1Rad
            deltaLon := lon2Rad - lon1Rad
            
            a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
                math.Cos(lat1Rad)*math.Cos(lat2Rad)*
                math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
            c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
            
            earthRadius := 6371.0
            distance := earthRadius * c
            
            inRegion := distance <= radius
            
            return map[string]interface{}{
                "in_region":    inRegion,
                "region_name":  regionName,
                "distance_km":  distance,
                "center_distance": distance,
            }, nil
        })
    
    defer functions.Unregister("geo_distance")
    defer functions.Unregister("in_region")
    
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // è½¦è¾†è½¨è¿¹åˆ†æ
    sql := `SELECT vehicle_id,
                   COUNT(*) as location_points,
                   AVG(speed) as avg_speed,
                   MAX(speed) as max_speed,
                   SUM(geo_distance(
                       LAG(latitude), LAG(longitude), 
                       latitude, longitude
                   )) as total_distance,
                   in_region(latitude, longitude, 39.9042, 116.4074, 10, 'Beijing') as region_info,
                   window_start() as trip_start
            FROM stream
            WHERE latitude IS NOT NULL AND longitude IS NOT NULL
            GROUP BY vehicle_id, TumblingWindow('10m')
            HAVING total_distance > 5 OR max_speed > 80`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("è½¦è¾†è½¨è¿¹åˆ†æ: %v\n", result)
    })
    
    // æ¨¡æ‹Ÿè½¦è¾†GPSæ•°æ®
    go func() {
        vehicles := []string{"è½¦A001", "è½¦B002", "è½¦C003"}
        
        // èµ·å§‹ä½ç½®ï¼ˆåŒ—äº¬å‘¨è¾¹ï¼‰
        startPositions := map[string][2]float64{
            "è½¦A001": {39.9042, 116.4074}, // å¤©å®‰é—?
            "è½¦B002": {39.9088, 116.3974}, // è¥¿å•
            "è½¦C003": {39.8888, 116.4188}, // å—ç«™
        }
        
        for {
            for _, vehicle := range vehicles {
                pos := startPositions[vehicle]
                
                // æ¨¡æ‹Ÿç§»åŠ¨ï¼šéšæœºåç§?
                latOffset := (rand.Float64() - 0.5) * 0.01  // çº?å…¬é‡ŒèŒƒå›´
                lonOffset := (rand.Float64() - 0.5) * 0.01
                
                newLat := pos[0] + latOffset
                newLon := pos[1] + lonOffset
                
                data := map[string]interface{}{
                    "vehicle_id": vehicle,
                    "latitude":   newLat,
                    "longitude":  newLon,
                    "speed":      20 + rand.Float64()*60, // 20-80 km/h
                    "timestamp":  time.Now(),
                }
                
                ssql.AddData(data)
                
                // æ›´æ–°ä½ç½®
                startPositions[vehicle] = [2]float64{newLat, newLon}
            }
            
            time.Sleep(10 * time.Second)
        }
    }()
    
    time.Sleep(2 * time.Hour)
}
```

## æ€§èƒ½ç›‘æ§

### 1. ç³»ç»Ÿèµ„æºç›‘æ§

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
)

func main() {
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // ç³»ç»Ÿèµ„æºç›‘æ§å’Œå‘Šè­?
    sql := `SELECT hostname,
                   AVG(cpu_percent) as avg_cpu,
                   MAX(cpu_percent) as max_cpu,
                   AVG(memory_percent) as avg_memory,
                   MAX(memory_percent) as max_memory,
                   AVG(disk_percent) as avg_disk,
                   COUNT(*) as sample_count,
                   CASE 
                       WHEN MAX(cpu_percent) > 90 THEN 'CPU_CRITICAL'
                       WHEN MAX(memory_percent) > 85 THEN 'MEMORY_CRITICAL'
                       WHEN MAX(disk_percent) > 90 THEN 'DISK_CRITICAL'
                       WHEN AVG(cpu_percent) > 70 THEN 'CPU_HIGH'
                       WHEN AVG(memory_percent) > 70 THEN 'MEMORY_HIGH'
                       ELSE 'NORMAL'
                   END as alert_level,
                   window_start() as check_time
            FROM stream
            GROUP BY hostname, TumblingWindow('5m')
            HAVING alert_level != 'NORMAL'`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("ç³»ç»Ÿèµ„æºå‘Šè­¦: %v\n", result)
    })
    
    // æ¨¡æ‹Ÿç³»ç»Ÿç›‘æ§æ•°æ®
    go func() {
        hosts := []string{"web-01", "web-02", "db-01", "cache-01"}
        
        for {
            for _, host := range hosts {
                var cpuPercent, memoryPercent, diskPercent float64
                
                if host == "db-01" && rand.Float64() < 0.2 {
                    // æ•°æ®åº“æœåŠ¡å™¨å¶å°”é«˜è´Ÿè½?
                    cpuPercent = 80 + rand.Float64()*15
                    memoryPercent = 75 + rand.Float64()*20
                    diskPercent = 60 + rand.Float64()*30
                } else {
                    // æ­£å¸¸è´Ÿè½½
                    cpuPercent = 10 + rand.Float64()*40
                    memoryPercent = 20 + rand.Float64()*50
                    diskPercent = 30 + rand.Float64()*30
                }
                
                data := map[string]interface{}{
                    "hostname":       host,
                    "cpu_percent":    cpuPercent,
                    "memory_percent": memoryPercent,
                    "disk_percent":   diskPercent,
                    "timestamp":      time.Now(),
                }
                
                ssql.AddData(data)
            }
            
            time.Sleep(30 * time.Second)
        }
    }()
    
    time.Sleep(1 * time.Hour)
}
```

## å®Œæ•´é¡¹ç›®ç¤ºä¾‹

### æ™ºèƒ½å·¥å‚ç›‘æ§ç³»ç»Ÿ

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
    "github.com/rulego/streamsql/functions"
)

func main() {
    // æ³¨å†Œè®¾å¤‡æ•ˆç‡è®¡ç®—å‡½æ•°
    functions.RegisterCustomFunction("equipment_efficiency", functions.TypeAnalytical,
        "å·¥å‚åˆ†æ", "è®¡ç®—è®¾å¤‡è¿è¡Œæ•ˆç‡", 3, 3,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            uptime, _ := functions.ConvertToFloat64(args[0])     // è¿è¡Œæ—¶é—´(åˆ†é’Ÿ)
            totalTime, _ := functions.ConvertToFloat64(args[1])  // æ€»æ—¶é—?åˆ†é’Ÿ)
            targetOutput, _ := functions.ConvertToFloat64(args[2]) // ç›®æ ‡äº§é‡
            
            if totalTime == 0 {
                return map[string]interface{}{
                    "efficiency_rate": 0.0,
                    "status":         "UNKNOWN",
                }, nil
            }
            
            efficiency := (uptime / totalTime) * 100
            
            var status string
            if efficiency >= 95 {
                status = "EXCELLENT"
            } else if efficiency >= 85 {
                status = "GOOD"
            } else if efficiency >= 70 {
                status = "FAIR"
            } else {
                status = "POOR"
            }
            
            return map[string]interface{}{
                "efficiency_rate": efficiency,
                "uptime_minutes":  uptime,
                "total_minutes":   totalTime,
                "status":         status,
            }, nil
        })
    defer functions.Unregister("equipment_efficiency")
    
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // å·¥å‚ç»¼åˆç›‘æ§
    sql := `SELECT workshop,
                   equipment_type,
                   COUNT(*) as event_count,
                   SUM(CASE WHEN status = 'RUNNING' THEN 1 ELSE 0 END) as running_count,
                   SUM(CASE WHEN status = 'ERROR' THEN 1 ELSE 0 END) as error_count,
                   AVG(temperature) as avg_temperature,
                   AVG(vibration) as avg_vibration,
                   SUM(production_count) as total_production,
                   equipment_efficiency(
                       SUM(CASE WHEN status = 'RUNNING' THEN 5 ELSE 0 END),
                       COUNT(*) * 5,
                       100
                   ) as efficiency_info,
                   window_start() as report_time
            FROM stream
            GROUP BY workshop, equipment_type, TumblingWindow('30m')
            HAVING error_count > 0 OR 
                   avg_temperature > 80 OR 
                   JSON_EXTRACT(efficiency_info, '$.efficiency_rate') < 80`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("å·¥å‚ç›‘æ§æŠ¥å‘Š: %v\n", result)
    })
    
    // æ¨¡æ‹Ÿå·¥å‚è®¾å¤‡æ•°æ®
    go func() {
        workshops := []string{"è½¦é—´A", "è½¦é—´B", "è½¦é—´C"}
        equipmentTypes := []string{"æœºåºŠ", "ç„Šæ¥æœ?, "åŒ…è£…æœ?, "è´¨æ£€ä»?}
        statuses := []string{"RUNNING", "IDLE", "MAINTENANCE", "ERROR"}
        
        for {
            for _, workshop := range workshops {
                for _, equipType := range equipmentTypes {
                    var status string
                    var temperature, vibration float64
                    var productionCount int
                    
                    // æ¨¡æ‹Ÿä¸åŒçš„è®¾å¤‡çŠ¶æ€?
                    if workshop == "è½¦é—´B" && equipType == "ç„Šæ¥æœ? && rand.Float64() < 0.1 {
                        // è½¦é—´Bçš„ç„Šæ¥æœºå¶å°”æ•…éšœ
                        status = "ERROR"
                        temperature = 90 + rand.Float64()*20
                        vibration = 8 + rand.Float64()*5
                        productionCount = 0
                    } else if rand.Float64() < 0.8 {
                        // 80%æ—¶é—´æ­£å¸¸è¿è¡Œ
                        status = "RUNNING"
                        temperature = 40 + rand.Float64()*30
                        vibration = 1 + rand.Float64()*3
                        productionCount = 5 + rand.Intn(10)
                    } else {
                        // å…¶ä»–çŠ¶æ€?
                        status = statuses[rand.Intn(len(statuses))]
                        temperature = 25 + rand.Float64()*20
                        vibration = rand.Float64() * 2
                        productionCount = rand.Intn(3)
                    }
                    
                    data := map[string]interface{}{
                        "workshop":        workshop,
                        "equipment_type":  equipType,
                        "equipment_id":    fmt.Sprintf("%s_%s_%d", workshop, equipType, rand.Intn(3)+1),
                        "status":          status,
                        "temperature":     temperature,
                        "vibration":       vibration,
                        "production_count": productionCount,
                        "timestamp":       time.Now(),
                    }
                    
                    ssql.AddData(data)
                }
            }
            
            time.Sleep(5 * time.Minute) // æ¯?åˆ†é’Ÿé‡‡é›†ä¸€æ¬?
        }
    }()
    
    time.Sleep(4 * time.Hour)
}
```

## è¿è¡Œç¤ºä¾‹

### å¦‚ä½•è¿è¡Œç¤ºä¾‹ä»£ç 

1. **åˆ›å»ºé¡¹ç›®ç›®å½•**
```bash
mkdir streamsql-examples
cd streamsql-examples
go mod init streamsql-examples
```

2. **æ·»åŠ ä¾èµ–**
```bash
go get github.com/rulego/streamsql
```

3. **åˆ›å»ºç¤ºä¾‹æ–‡ä»¶**
å°†ä¸Šè¿°ä»»ä¸€ç¤ºä¾‹ä»£ç ä¿å­˜ä¸?`main.go`

4. **è¿è¡Œç¤ºä¾‹**
```bash
go run main.go
```

### ç¤ºä¾‹è¾“å‡ºæ ¼å¼

å¤§å¤šæ•°ç¤ºä¾‹ä¼šäº§ç”Ÿç±»ä¼¼ä»¥ä¸‹æ ¼å¼çš„è¾“å‡ºï¼š

```
èšåˆç»“æœ: [map[deviceId:sensor001 avg_temp:25.4 sample_count:12 window_start:1704672000000000000]]
å¼‚å¸¸æ£€æµ‹å‘Šè­? [map[deviceId:temp_sensor anomaly_info:map[is_anomaly:true severity:high z_score:3.2]]]
è®¾å¤‡å¥åº·å‘Šè­¦: [map[deviceId:device002 health:map[score:45 status:æ•…éšœ alerts:[é«˜æ¸© ç”µå‹ä¸è¶³]]]]
```

### è‡ªå®šä¹‰å’Œæ‰©å±•

æ¯ä¸ªç¤ºä¾‹éƒ½å¯ä»¥æ ¹æ®æ‚¨çš„å…·ä½“éœ€æ±‚è¿›è¡Œè‡ªå®šä¹‰ï¼?

- **ä¿®æ”¹SQLæŸ¥è¯¢**ï¼šè°ƒæ•´çª—å£å¤§å°ã€è¿‡æ»¤æ¡ä»¶ã€èšåˆå‡½æ•?
- **æ·»åŠ è‡ªå®šä¹‰å‡½æ•?*ï¼šå®ç°ç‰¹å®šä¸šåŠ¡é€»è¾‘
- **è°ƒæ•´æ•°æ®æ¨¡æ‹Ÿ**ï¼šæ›´æ”¹æ•°æ®ç”Ÿæˆé€»è¾‘ä»¥åŒ¹é…å®é™…åœºæ™?
- **å¢åŠ è¾“å‡ºå¤„ç†**ï¼šå°†ç»“æœå‘é€åˆ°æ•°æ®åº“ã€æ¶ˆæ¯é˜Ÿåˆ—æˆ–å…¶ä»–ç³»ç»Ÿ

## ä¸‹ä¸€æ­?

ç°åœ¨æ‚¨å·²ç»çœ‹åˆ°äº†ä¸°å¯Œçš„StreamSQLåº”ç”¨ç¤ºä¾‹ï¼Œå»ºè®®ï¼š

- ğŸ“š [APIå‚è€ƒ](../08.APIå‚è€?) - æŸ¥çœ‹å®Œæ•´çš„APIæ–‡æ¡£
- ğŸ“– [æœ€ä½³å®è·µ](../09.æœ€ä½³å®è·?) - å­¦ä¹ ç”Ÿäº§ç¯å¢ƒä½¿ç”¨å»ºè®®
- ğŸ”™ [è‡ªå®šä¹‰å‡½æ•°](../06.è‡ªå®šä¹‰å‡½æ•?) - æ·±å…¥äº†è§£å‡½æ•°å¼€å?
- ğŸ  [è¿”å›é¦–é¡µ](../) - å›åˆ°æ–‡æ¡£é¦–é¡µ 

### 2. å¤šæµæ•°æ®åˆå¹¶

å½“æ•°æ®æ¥è‡ªå¤šä¸ªç‹¬ç«‹çš„æ•°æ®æºæ—¶ï¼Œæˆ‘ä»¬éœ€è¦åŸºäºæŸäº›å…³é”®å­—æ®µè¿›è¡Œåˆå¹¶ã€?

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
    "github.com/rulego/streamsql/functions"
)

func main() {
    // æ³¨å†Œæ•°æ®åˆå¹¶å‡½æ•°
    functions.RegisterCustomFunction("merge_data", functions.TypeAnalytical,
        "æ•°æ®åˆå¹¶", "åˆå¹¶å¤šä¸ªæ•°æ®æºçš„æ•°æ®", 1, 10,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            result := make(map[string]interface{})
            
            for i, arg := range args {
                if data, ok := arg.(map[string]interface{}); ok {
                    for k, v := range data {
                        if v != nil {
                            result[k] = v
                        }
                    }
                } else if arg != nil {
                    result[fmt.Sprintf("field_%d", i)] = arg
                }
            }
            
            return result, nil
        })
    defer functions.Unregister("merge_data")
    
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // å¤šæµæ•°æ®åˆå¹¶ï¼šåŸºäºç”¨æˆ·IDå…³è”ç”¨æˆ·è¡Œä¸ºå’Œè®¢å•æ•°æ?
    sql := `SELECT user_id,
                   COUNT(CASE WHEN event_type = 'page_view' THEN 1 END) as page_views,
                   COUNT(CASE WHEN event_type = 'purchase' THEN 1 END) as purchases,
                   SUM(CASE WHEN order_amount IS NOT NULL THEN order_amount ELSE 0 END) as total_amount,
                   AVG(CASE WHEN session_duration IS NOT NULL THEN session_duration END) as avg_session_time,
                   MAX(CASE WHEN event_type = 'page_view' THEN page_url END) as last_page,
                   MAX(CASE WHEN event_type = 'purchase' THEN product_name END) as last_purchase,
                   COUNT(DISTINCT session_id) as total_sessions,
                   window_start() as analysis_period
            FROM stream
            WHERE user_id IS NOT NULL
            GROUP BY user_id, TumblingWindow('2m')
            HAVING page_views > 0 OR purchases > 0`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("ç”¨æˆ·è¡Œä¸ºåˆå¹¶åˆ†æ: %v\n", result)
    })
    
    // æ¨¡æ‹Ÿå¤šæºæ•°æ®
    go simulateMultiStreamData(ssql)
    
    time.Sleep(5 * time.Minute)
}

func simulateMultiStreamData(ssql *streamsql.StreamSQL) {
    users := []string{"user_001", "user_002", "user_003"}
    pages := []string{"/home", "/products", "/cart", "/checkout"}
    products := []string{"Product A", "Product B", "Product C"}
    
    for i := 0; i < 100; i++ {
        user := users[rand.Intn(len(users))]
        sessionId := fmt.Sprintf("session_%d", rand.Intn(10))
        
        // ç”¨æˆ·è¡Œä¸ºæ•°æ®æµ?
        if rand.Float64() < 0.8 {
            behaviorData := map[string]interface{}{
                "user_id":          user,
                "session_id":       sessionId,
                "event_type":       "page_view",
                "page_url":         pages[rand.Intn(len(pages))],
                "session_duration": 30 + rand.Intn(300), // 30-330ç§?
                "timestamp":        time.Now(),
            }
            ssql.AddData(behaviorData)
        }
        
        // è®¢å•æ•°æ®æµ?
        if rand.Float64() < 0.2 {
            orderData := map[string]interface{}{
                "user_id":      user,
                "session_id":   sessionId,
                "event_type":   "purchase",
                "product_name": products[rand.Intn(len(products))],
                "order_amount": 50.0 + rand.Float64()*200.0,
                "timestamp":    time.Now(),
            }
            ssql.AddData(orderData)
        }
        
        time.Sleep(2 * time.Second)
    }
}

## å˜åŒ–æ•°æ®æ•æ‰

### 1. è®¾å¤‡çŠ¶æ€å˜åŒ–æ£€æµ?

ç›‘æ§è®¾å¤‡çŠ¶æ€å˜åŒ–ï¼Œå¹¶æ•æ‰çŠ¶æ€è½¬æ¢äº‹ä»¶ã€?

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
    "github.com/rulego/streamsql/functions"
)

func main() {
    // æ³¨å†ŒçŠ¶æ€å˜åŒ–æ£€æµ‹å‡½æ•?
    functions.RegisterCustomFunction("detect_state_change", functions.TypeAnalytical,
        "å˜åŒ–æ£€æµ?, "æ£€æµ‹çŠ¶æ€å˜åŒ?, 2, 3,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            currentState, _ := functions.ConvertToString(args[0])
            previousState, _ := functions.ConvertToString(args[1])
            
            var changeType string
            if len(args) > 2 {
                changeType, _ = functions.ConvertToString(args[2])
            } else {
                changeType = "unknown"
            }
            
            hasChanged := currentState != previousState
            
            var severity string
            if hasChanged {
                // çŠ¶æ€å˜åŒ–ä¸¥é‡æ€§è¯„ä¼?
                if (previousState == "online" && currentState == "offline") ||
                   (previousState == "normal" && currentState == "error") {
                    severity = "critical"
                } else if (previousState == "offline" && currentState == "online") ||
                         (previousState == "error" && currentState == "normal") {
                    severity = "info"
                } else {
                    severity = "warning"
                }
            } else {
                severity = "none"
            }
            
            return map[string]interface{}{
                "has_changed":     hasChanged,
                "from_state":      previousState,
                "to_state":        currentState,
                "change_type":     changeType,
                "severity":        severity,
            }, nil
        })
    defer functions.Unregister("detect_state_change")
    
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // çŠ¶æ€å˜åŒ–æ£€æµ?
    sql := `SELECT device_id,
                   status as current_status,
                   LAG(status) as previous_status,
                   detect_state_change(status, LAG(status), 'device_status') as change_info,
                   temperature,
                   error_count,
                   timestamp
            FROM stream
            WHERE device_id IS NOT NULL
            HAVING JSON_EXTRACT(change_info, '$.has_changed') = true`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("è®¾å¤‡çŠ¶æ€å˜åŒ? %v\n", result)
    })
    
    // æ¨¡æ‹Ÿè®¾å¤‡çŠ¶æ€æ•°æ?
    go simulateDeviceStatusData(ssql)
    
    time.Sleep(5 * time.Minute)
}

func simulateDeviceStatusData(ssql *streamsql.StreamSQL) {
    devices := map[string]string{
        "device_001": "online",
        "device_002": "online", 
        "device_003": "offline",
    }
    
    statuses := []string{"online", "offline", "maintenance", "error", "normal"}
    
    for i := 0; i < 100; i++ {
        for deviceId, currentStatus := range devices {
            var newStatus string
            
            // æ¨¡æ‹ŸçŠ¶æ€å˜åŒ–é€»è¾‘
            if rand.Float64() < 0.1 { // 10%æ¦‚ç‡çŠ¶æ€å˜åŒ?
                if currentStatus == "online" && rand.Float64() < 0.3 {
                    newStatus = "offline" // è®¾å¤‡ç¦»çº¿
                } else if currentStatus == "offline" && rand.Float64() < 0.5 {
                    newStatus = "online" // è®¾å¤‡ä¸Šçº¿
                } else if currentStatus == "normal" && rand.Float64() < 0.2 {
                    newStatus = "error" // è®¾å¤‡æ•…éšœ
                } else {
                    newStatus = statuses[rand.Intn(len(statuses))]
                }
                devices[deviceId] = newStatus
            } else {
                newStatus = currentStatus // çŠ¶æ€ä¸å?
            }
            
            data := map[string]interface{}{
                "device_id":   deviceId,
                "status":      newStatus,
                "temperature": 20.0 + rand.Float64()*30,
                "error_count": rand.Intn(5),
                "timestamp":   time.Now(),
            }
            
            ssql.AddData(data)
            fmt.Printf("è®¾å¤‡ %s: %s -> %s\n", deviceId, currentStatus, newStatus)
        }
        
        time.Sleep(5 * time.Second)
    }
}
```

### 2. æ•°æ®é˜ˆå€¼å˜åŒ–ç›‘æ?

ç›‘æ§æ•°å€¼å‹æ•°æ®çš„é˜ˆå€¼å˜åŒ–ï¼Œæ£€æµ‹è¶…é™å’Œæ¢å¤äº‹ä»¶ã€?

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
    "github.com/rulego/streamsql/functions"
)

func main() {
    // æ³¨å†Œé˜ˆå€¼å˜åŒ–æ£€æµ‹å‡½æ•?
    functions.RegisterCustomFunction("threshold_change", functions.TypeAnalytical,
        "é˜ˆå€¼æ£€æµ?, "æ£€æµ‹æ•°å€¼é˜ˆå€¼å˜åŒ?, 4, 6,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            currentValue, _ := functions.ConvertToFloat64(args[0])
            previousValue, _ := functions.ConvertToFloat64(args[1])
            lowThreshold, _ := functions.ConvertToFloat64(args[2])
            highThreshold, _ := functions.ConvertToFloat64(args[3])
            
            var metricName string = "value"
            var unit string = ""
            if len(args) > 4 {
                metricName, _ = functions.ConvertToString(args[4])
            }
            if len(args) > 5 {
                unit, _ = functions.ConvertToString(args[5])
            }
            
            // åˆ¤æ–­å½“å‰çŠ¶æ€?
            var currentState string
            if currentValue > highThreshold {
                currentState = "high"
            } else if currentValue < lowThreshold {
                currentState = "low"
            } else {
                currentState = "normal"
            }
            
            // åˆ¤æ–­ä¹‹å‰çŠ¶æ€?
            var previousState string
            if previousValue > highThreshold {
                previousState = "high"
            } else if previousValue < lowThreshold {
                previousState = "low"
            } else {
                previousState = "normal"
            }
            
            hasChanged := currentState != previousState
            
            var eventType string
            if hasChanged {
                if previousState == "normal" && currentState == "high" {
                    eventType = "threshold_exceeded"
                } else if previousState == "normal" && currentState == "low" {
                    eventType = "threshold_underrun"
                } else if (previousState == "high" || previousState == "low") && currentState == "normal" {
                    eventType = "threshold_recovered"
                } else {
                    eventType = "threshold_changed"
                }
            }
            
            return map[string]interface{}{
                "has_changed":      hasChanged,
                "event_type":       eventType,
                "current_state":    currentState,
                "previous_state":   previousState,
                "current_value":    currentValue,
                "previous_value":   previousValue,
                "low_threshold":    lowThreshold,
                "high_threshold":   highThreshold,
                "metric_name":      metricName,
                "unit":            unit,
                "breach_amount":   0.0, // å¯ä»¥è®¡ç®—è¶…å‡ºé˜ˆå€¼çš„é‡?
            }, nil
        })
    defer functions.Unregister("threshold_change")
    
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // é˜ˆå€¼å˜åŒ–ç›‘æ?
    sql := `SELECT sensor_id,
                   metric_type,
                   value as current_value,
                   LAG(value) as previous_value,
                   threshold_change(
                       value, 
                       LAG(value), 
                       low_limit, 
                       high_limit, 
                       metric_type,
                       unit
                   ) as threshold_event,
                   timestamp
            FROM stream
            WHERE value IS NOT NULL AND LAG(value) IS NOT NULL
            HAVING JSON_EXTRACT(threshold_event, '$.has_changed') = true`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("é˜ˆå€¼å˜åŒ–äº‹ä»? %v\n", result)
    })
    
    // æ¨¡æ‹Ÿä¼ æ„Ÿå™¨é˜ˆå€¼ç›‘æ§æ•°æ?
    go simulateThresholdData(ssql)
    
    time.Sleep(5 * time.Minute)
}

func simulateThresholdData(ssql *streamsql.StreamSQL) {
    sensors := []map[string]interface{}{
        {
            "sensor_id":   "temp_001",
            "metric_type": "temperature",
            "unit":        "Â°C",
            "low_limit":   5.0,
            "high_limit":  35.0,
            "base_value":  25.0,
        },
        {
            "sensor_id":   "pressure_001", 
            "metric_type": "pressure",
            "unit":        "kPa",
            "low_limit":   80.0,
            "high_limit":  120.0,
            "base_value":  100.0,
        },
        {
            "sensor_id":   "humidity_001",
            "metric_type": "humidity",
            "unit":        "%",
            "low_limit":   20.0,
            "high_limit":  80.0,
            "base_value":  50.0,
        },
    }
    
    for i := 0; i < 200; i++ {
        for _, sensor := range sensors {
            baseValue := sensor["base_value"].(float64)
            
            var value float64
            if i > 50 && i < 70 && sensor["sensor_id"] == "temp_001" {
                // æ¨¡æ‹Ÿæ¸©åº¦ä¼ æ„Ÿå™¨å¼‚å¸¸é«˜æ¸?
                value = 40.0 + rand.Float64()*10
            } else if i > 100 && i < 120 && sensor["sensor_id"] == "pressure_001" {
                // æ¨¡æ‹Ÿå‹åŠ›ä¼ æ„Ÿå™¨å¼‚å¸¸ä½å?
                value = 70.0 + rand.Float64()*5
            } else {
                // æ­£å¸¸æ³¢åŠ¨
                value = baseValue + (rand.Float64()-0.5)*10
            }
            
            data := map[string]interface{}{
                "sensor_id":   sensor["sensor_id"],
                "metric_type": sensor["metric_type"],
                "value":       value,
                "unit":        sensor["unit"],
                "low_limit":   sensor["low_limit"],
                "high_limit":  sensor["high_limit"],
                "timestamp":   time.Now(),
            }
            
            ssql.AddData(data)
            fmt.Printf("ä¼ æ„Ÿå™?%s (%s): %.2f %s\n", 
                sensor["sensor_id"], sensor["metric_type"], value, sensor["unit"])
        }
        
        time.Sleep(3 * time.Second)
    }
}
```

### 3. é…ç½®å˜åŒ–è·Ÿè¸ª

ç›‘æ§ç³»ç»Ÿé…ç½®å˜åŒ–ï¼Œè®°å½•å˜æ›´å†å²ã€?

```go
package main

import (
    "fmt"
    "time"
    "github.com/rulego/streamsql"
    "github.com/rulego/streamsql/functions"
)

func main() {
    // æ³¨å†Œé…ç½®å˜åŒ–è·Ÿè¸ªå‡½æ•°
    functions.RegisterCustomFunction("track_config_change", functions.TypeAnalytical,
        "é…ç½®è·Ÿè¸ª", "è·Ÿè¸ªé…ç½®å˜åŒ–", 3, 4,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            configKey, _ := functions.ConvertToString(args[0])
            newValue := args[1]
            oldValue := args[2]
            
            var changeReason string = "manual"
            if len(args) > 3 {
                changeReason, _ = functions.ConvertToString(args[3])
            }
            
            hasChanged := fmt.Sprintf("%v", newValue) != fmt.Sprintf("%v", oldValue)
            
            var changeType string
            if hasChanged {
                if oldValue == nil {
                    changeType = "created"
                } else if newValue == nil {
                    changeType = "deleted"
                } else {
                    changeType = "modified"
                }
            }
            
            return map[string]interface{}{
                "config_key":     configKey,
                "has_changed":    hasChanged,
                "change_type":    changeType,
                "old_value":      oldValue,
                "new_value":      newValue,
                "change_reason":  changeReason,
            }, nil
        })
    defer functions.Unregister("track_config_change")
    
    ssql := streamsql.New()
    defer ssql.Stop()
    
    // é…ç½®å˜åŒ–è·Ÿè¸ª
    sql := `SELECT system_name,
                   config_key,
                   config_value,
                   LAG(config_value) as previous_value,
                   track_config_change(
                       config_key, 
                       config_value, 
                       LAG(config_value),
                       change_reason
                   ) as change_info,
                   user_id,
                   timestamp
            FROM stream
            WHERE config_key IS NOT NULL
            HAVING JSON_EXTRACT(change_info, '$.has_changed') = true`
    
    err := ssql.Execute(sql)
    if err != nil {
        panic(err)
    }
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("é…ç½®å˜åŒ–è®°å½•: %v\n", result)
    })
    
    // æ¨¡æ‹Ÿé…ç½®å˜åŒ–æ•°æ®
    go simulateConfigChanges(ssql)
    
    time.Sleep(3 * time.Minute)
}

func simulateConfigChanges(ssql *streamsql.StreamSQL) {
    systems := []string{"web_server", "database", "cache_server"}
    configs := map[string][]interface{}{
        "max_connections": {100, 200, 150, 300},
        "timeout_seconds": {30, 60, 45, 90},
        "enable_ssl":      {true, false},
        "log_level":       {"INFO", "DEBUG", "WARN", "ERROR"},
        "cache_size_mb":   {512, 1024, 256, 2048},
    }
    
    users := []string{"admin", "operator", "system"}
    reasons := []string{"manual", "auto_scaling", "maintenance", "emergency"}
    
    for i := 0; i < 50; i++ {
        system := systems[rand.Intn(len(systems))]
        
        // éšæœºé€‰æ‹©é…ç½®é¡?
        var configKey string
        var values []interface{}
        for k, v := range configs {
            configKey = k
            values = v
            break
        }
        
        // æ¨¡æ‹Ÿé…ç½®å˜åŒ–
        if rand.Float64() < 0.3 { // 30%æ¦‚ç‡å‘ç”Ÿé…ç½®å˜åŒ–
            newValue := values[rand.Intn(len(values))]
            
            data := map[string]interface{}{
                "system_name":   system,
                "config_key":    configKey,
                "config_value":  newValue,
                "user_id":       users[rand.Intn(len(users))],
                "change_reason": reasons[rand.Intn(len(reasons))],
                "timestamp":     time.Now(),
            }
            
            ssql.AddData(data)
            fmt.Printf("é…ç½®å˜æ›´: %s.%s = %v\n", system, configKey, newValue)
        }
        
        time.Sleep(4 * time.Second)
    }
}
```

## IoTè®¾å¤‡ç›‘æ§

---
title: æœ€ä½³å®è·?date: 2024-01-15 10:09:00
permalink: /pages/streamsql/09/
article: false
author:
  name: StreamSQL
  link: https://github.com/rulego/streamsql
---
# æœ€ä½³å®è·?
æœ¬ç« æä¾›StreamSQLåœ¨ç”Ÿäº§ç¯å¢ƒä¸­çš„ä½¿ç”¨å»ºè®®å’Œæ€§èƒ½ä¼˜åŒ–æŒ‡å—ã€?
## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### é€‰æ‹©åˆé€‚çš„æ€§èƒ½æ¨¡å¼

æ ¹æ®åº”ç”¨åœºæ™¯é€‰æ‹©æœ€é€‚åˆçš„æ€§èƒ½æ¨¡å¼ï¼?
```go
// é«˜ååé‡åœºæ™¯ - æ‰¹å¤„ç†ã€æ•°æ®åˆ†æ?ssql := streamsql.New(streamsql.WithHighPerformance())

// ä½å»¶è¿Ÿåœºæ™?- å®æ—¶å‘Šè­¦ã€ç›‘æ?ssql := streamsql.New(streamsql.WithLowLatency())

// å…³é”®æ•°æ®åœºæ™¯ - é‡‘èäº¤æ˜“ã€å®‰å…¨ç›‘æ?ssql := streamsql.New(streamsql.WithZeroDataLoss())

// è‡ªå®šä¹‰é…ç½?customConfig := &types.PerformanceConfig{
    BufferSize:    1000,
    FlushInterval: 100 * time.Millisecond,
    MaxRetries:    3,
}
ssql := streamsql.New(streamsql.WithCustomPerformance(customConfig))
```

### çª—å£å¤§å°ä¼˜åŒ–

**åŸåˆ™ï¼?*
- çª—å£å¤ªå°ï¼šè®¡ç®—å¼€é”€å¤§ï¼Œç»“æœé¢‘ç¹
- çª—å£å¤ªå¤§ï¼šå†…å­˜å ç”¨é«˜ï¼Œå»¶è¿Ÿå¢åŠ?
```go
// â?é¿å…è¿‡å°çš„çª—å?"GROUP BY TumblingWindow('100ms')"  // æ¯?00æ¯«ç§’è§¦å‘ä¸€æ¬?
// âœ?æ¨èçš„çª—å£å¤§å°?"GROUP BY TumblingWindow('5s')"     // 5ç§’çª—å£ï¼Œé€‚åˆå¤§å¤šæ•°åœºæ™?"GROUP BY TumblingWindow('1m')"     // 1åˆ†é’Ÿçª—å£ï¼Œé€‚åˆç»Ÿè®¡åˆ†æ

// âœ?æ»‘åŠ¨çª—å£çš„åˆç†é…ç½?"GROUP BY SlidingWindow('30s', '10s')"  // 30ç§’çª—å£ï¼Œ10ç§’æ»‘åŠ?```

### æŸ¥è¯¢ä¼˜åŒ–

#### 1. è¿‡æ»¤æ¡ä»¶å‰ç½®

```go
// âœ?å¥½çš„åšæ³•ï¼šåœ¨WHEREå­å¥ä¸­å°½æ—©è¿‡æ»?SELECT deviceId, AVG(temperature) 
FROM stream 
WHERE deviceId LIKE 'sensor%' AND temperature > 0  -- å…ˆè¿‡æ»?GROUP BY deviceId, TumblingWindow('5s')
HAVING AVG(temperature) > 25                       -- å†èšåˆè¿‡æ»?
// â?é¿å…ï¼šåœ¨HAVINGä¸­åšåŸºç¡€è¿‡æ»¤
SELECT deviceId, AVG(temperature) 
FROM stream 
GROUP BY deviceId, TumblingWindow('5s')
HAVING deviceId LIKE 'sensor%' AND AVG(temperature) > 25
```

#### 2. åˆç†ä½¿ç”¨å‡½æ•°

```go
// âœ?ä½¿ç”¨å†…ç½®å‡½æ•°
SELECT UPPER(deviceType), COUNT(*) FROM stream

// âœ?é¿å…å¤æ‚çš„åµŒå¥—å‡½æ•°è°ƒç”?SELECT deviceId, 
       CASE WHEN temperature > 30 THEN 'hot' ELSE 'normal' END
FROM stream

// â?é¿å…è¿‡åº¦å¤æ‚çš„è¡¨è¾¾å¼
SELECT UPPER(CONCAT(SUBSTRING(deviceId, 1, 3), '_', deviceType)) FROM stream
```

## ğŸ›¡ï¸?é”™è¯¯å¤„ç†

### å¥å£®çš„é”™è¯¯å¤„ç?
```go
func createStreamSQL() (*streamsql.Streamsql, error) {
    ssql := streamsql.New(streamsql.WithHighPerformance())
    
    sql := `SELECT deviceId, AVG(temperature) as avg_temp
            FROM stream 
            WHERE temperature IS NOT NULL
            GROUP BY deviceId, TumblingWindow('5s')`
    
    if err := ssql.Execute(sql); err != nil {
        ssql.Stop() // ç¡®ä¿èµ„æºæ¸…ç†
        return nil, fmt.Errorf("æ‰§è¡ŒSQLå¤±è´¥: %w", err)
    }
    
    // æ·»åŠ é”™è¯¯å¤„ç†çš„Sink
    ssql.Stream().AddSink(func(result interface{}) {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("å¤„ç†ç»“æœæ—¶å‘ç”Ÿpanic: %v", r)
            }
        }()
        
        if result == nil {
            log.Println("æ”¶åˆ°ç©ºç»“æ?)
            return
        }
        
        // å¤„ç†æ­£å¸¸ç»“æœ
        processResult(result)
    })
    
    return ssql, nil
}
```

### æ•°æ®éªŒè¯

```go
func validateAndAddData(ssql *streamsql.Streamsql, data map[string]interface{}) error {
    // éªŒè¯å¿…éœ€å­—æ®µ
    if deviceId, ok := data["deviceId"]; !ok || deviceId == "" {
        return errors.New("deviceIdå­—æ®µç¼ºå¤±æˆ–ä¸ºç©?)
    }
    
    // éªŒè¯æ•°æ®ç±»å‹
    if temp, ok := data["temperature"]; ok {
        if _, err := cast.ToFloat64E(temp); err != nil {
            return fmt.Errorf("temperatureå­—æ®µç±»å‹é”™è¯¯: %w", err)
        }
    }
    
    // éªŒè¯æ•°æ®èŒƒå›´
    if temp, _ := cast.ToFloat64E(data["temperature"]); temp < -50 || temp > 100 {
        return errors.New("temperatureè¶…å‡ºåˆç†èŒƒå›´")
    }
    
    ssql.AddData(data)
    return nil
}
```

## ğŸ“Š ç›‘æ§å’Œè°ƒè¯?
### æ€§èƒ½ç›‘æ§

```go
type StreamMonitor struct {
    processedCount int64
    errorCount     int64
    lastProcessTime time.Time
    mu             sync.RWMutex
}

func (m *StreamMonitor) AddSinkWithMonitoring(ssql *streamsql.Streamsql) {
    ssql.Stream().AddSink(func(result interface{}) {
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.processedCount++
        m.lastProcessTime = time.Now()
        
        if result == nil {
            m.errorCount++
            return
        }
        
        // å¤„ç†æ­£å¸¸ç»“æœ
        processResult(result)
    })
}

func (m *StreamMonitor) GetStats() (processed, errors int64, lastTime time.Time) {
    m.mu.RLock()
    defer m.mu.RUnlock()
    return m.processedCount, m.errorCount, m.lastProcessTime
}
```

### è°ƒè¯•æŠ€å·?
```go
// 1. æ·»åŠ è°ƒè¯•æ—¥å¿—
ssql.Stream().AddSink(func(result interface{}) {
    log.Printf("[DEBUG] æ”¶åˆ°ç»“æœ: %+v", result)
    
    // æ£€æŸ¥ç»“æœç»“æ?    if rows, ok := result.([]types.Row); ok {
        for i, row := range rows {
            log.Printf("[DEBUG] ç¬?dè¡? %+v", i, row)
        }
    }
})

// 2. éªŒè¯SQLè¯­æ³•
func validateSQL(sql string) error {
    ssql := streamsql.New()
    defer ssql.Stop()
    
    if err := ssql.Execute(sql); err != nil {
        return fmt.Errorf("SQLè¯­æ³•é”™è¯¯: %w", err)
    }
    
    return nil
}

// 3. æµ‹è¯•æ•°æ®æ ¼å¼
func testDataFormat() {
    ssql := streamsql.New()
    defer ssql.Stop()
    
    sql := "SELECT * FROM stream"
    ssql.Execute(sql)
    
    ssql.Stream().AddSink(func(result interface{}) {
        fmt.Printf("æ•°æ®æ ¼å¼: %T, å†…å®¹: %+v\n", result, result)
    })
    
    // å‘é€æµ‹è¯•æ•°æ?    testData := map[string]interface{}{
        "deviceId": "test001",
        "value": 123.45,
    }
    ssql.AddData(testData)
}
```

## ğŸ”§ éƒ¨ç½²å»ºè®®

### å®¹å™¨åŒ–éƒ¨ç½?
```dockerfile
# Dockerfile
FROM golang:1.18-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o streamsql-app .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/streamsql-app .
CMD ["./streamsql-app"]
```

### é…ç½®ç®¡ç†

```go
type Config struct {
    PerformanceMode string        `yaml:"performance_mode"`
    BufferSize      int           `yaml:"buffer_size"`
    FlushInterval   time.Duration `yaml:"flush_interval"`
    LogLevel        string        `yaml:"log_level"`
}

func LoadConfig(path string) (*Config, error) {
    data, err := ioutil.ReadFile(path)
    if err != nil {
        return nil, err
    }
    
    var config Config
    if err := yaml.Unmarshal(data, &config); err != nil {
        return nil, err
    }
    
    return &config, nil
}

func CreateStreamSQLFromConfig(config *Config) *streamsql.Streamsql {
    var options []streamsql.Option
    
    switch config.PerformanceMode {
    case "high_performance":
        options = append(options, streamsql.WithHighPerformance())
    case "low_latency":
        options = append(options, streamsql.WithLowLatency())
    case "zero_data_loss":
        options = append(options, streamsql.WithZeroDataLoss())
    }
    
    return streamsql.New(options...)
}
```

### å¥åº·æ£€æŸ?
```go
type HealthChecker struct {
    ssql       *streamsql.Streamsql
    lastHealth time.Time
    mu         sync.RWMutex
}

func (h *HealthChecker) Check() bool {
    h.mu.RLock()
    defer h.mu.RUnlock()
    
    // æ£€æŸ¥æœ€è¿‘æ˜¯å¦æœ‰æ•°æ®å¤„ç†
    return time.Since(h.lastHealth) < 30*time.Second
}

func (h *HealthChecker) UpdateHealth() {
    h.mu.Lock()
    defer h.mu.Unlock()
    h.lastHealth = time.Now()
}

// HTTPå¥åº·æ£€æŸ¥ç«¯ç‚?func healthHandler(checker *HealthChecker) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        if checker.Check() {
            w.WriteHeader(http.StatusOK)
            w.Write([]byte("OK"))
        } else {
            w.WriteHeader(http.StatusServiceUnavailable)
            w.Write([]byte("Service Unavailable"))
        }
    }
}
```

## ğŸ”’ å®‰å…¨å»ºè®®

### è¾“å…¥éªŒè¯

```go
// éªŒè¯SQLæ³¨å…¥é£é™©
func validateSQL(sql string) error {
    // æ£€æŸ¥å±é™©å…³é”®å­—
    dangerous := []string{"DROP", "DELETE", "UPDATE", "INSERT", "CREATE"}
    upperSQL := strings.ToUpper(sql)
    
    for _, keyword := range dangerous {
        if strings.Contains(upperSQL, keyword) {
            return fmt.Errorf("SQLåŒ…å«å±é™©å…³é”®å­? %s", keyword)
        }
    }
    
    return nil
}

// æ•°æ®è„±æ•
func sanitizeData(data map[string]interface{}) map[string]interface{} {
    sensitiveFields := []string{"password", "token", "secret"}
    
    result := make(map[string]interface{})
    for k, v := range data {
        if contains(sensitiveFields, strings.ToLower(k)) {
            result[k] = "***"
        } else {
            result[k] = v
        }
    }
    
    return result
}
```

## ğŸ“ˆ æ‰©å±•æ€§è€ƒè™‘

### æ°´å¹³æ‰©å±•

```go
// æ•°æ®åˆ†ç‰‡
type ShardedStreamSQL struct {
    shards []streamsql.Streamsql
    count  int64
}

func (s *ShardedStreamSQL) AddData(data map[string]interface{}) {
    // æ ¹æ®deviceIdè¿›è¡Œåˆ†ç‰‡
    deviceId := data["deviceId"].(string)
    shardIndex := hash(deviceId) % len(s.shards)
    
    s.shards[shardIndex].AddData(data)
    atomic.AddInt64(&s.count, 1)
}

func hash(s string) int {
    h := fnv.New32a()
    h.Write([]byte(s))
    return int(h.Sum32())
}
```

### ä¸RuleGoé›†æˆ

```go
// ä½¿ç”¨RuleGoä½œä¸ºæ•°æ®æº?func integrateWithRuleGo(ssql *streamsql.Streamsql) {
    // åˆ›å»ºRuleGoè§„åˆ™é“?    ruleEngine := rulego.New()
    
    // å®šä¹‰è§„åˆ™é“¾ï¼Œå°†æ•°æ®è½¬å‘åˆ°StreamSQL
    ruleChain := `{
        "ruleChain": {
            "nodes": [
                {
                    "id": "s1",
                    "type": "jsTransform",
                    "configuration": {
                        "jsScript": "return {deviceId: msg.id, temperature: msg.temp};"
                    }
                }
            ]
        }
    }`
    
    // åŠ è½½è§„åˆ™é“?    ruleEngine.ReloadSelf([]byte(ruleChain))
    
    // è®¾ç½®å›è°ƒï¼Œå°†å¤„ç†ç»“æœå‘é€åˆ°StreamSQL
    ruleEngine.OnMsg(func(msg types.RuleMsg) {
        if data, ok := msg.Data.(map[string]interface{}); ok {
            ssql.AddData(data)
        }
    })
}
```

---

## æ€»ç»“

éµå¾ªè¿™äº›æœ€ä½³å®è·µå¯ä»¥å¸®åŠ©æ‚¨ï¼?
1. **æé«˜æ€§èƒ½**ï¼šé€‰æ‹©åˆé€‚çš„é…ç½®å’Œä¼˜åŒ–æŸ¥è¯?2. **å¢å¼ºç¨³å®šæ€?*ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œç›‘æ?3. **ç®€åŒ–è¿ç»?*ï¼šæ ‡å‡†åŒ–çš„éƒ¨ç½²å’Œé…ç½®ç®¡ç†
4. **ä¿éšœå®‰å…¨**ï¼šè¾“å…¥éªŒè¯å’Œæ•°æ®è„±æ•
5. **æ”¯æŒæ‰©å±•**ï¼šä¸ºæœªæ¥çš„æ‰©å±•éœ€æ±‚åšå¥½å‡†å¤?
è®°ä½ï¼Œæœ€ä½³å®è·µéœ€è¦æ ¹æ®å…·ä½“çš„ä¸šåŠ¡åœºæ™¯è¿›è¡Œè°ƒæ•´ã€‚å»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å‰è¿›è¡Œå……åˆ†çš„æµ‹è¯•å’Œæ€§èƒ½è¯„ä¼°ã€

---
title: è‡ªå®šä¹‰å‡½æ•°
date: 2025-07-23 19:06:00
permalink: /pages/streamsql-functions/
article: false
author: 
  name: StreamSQL
  link: https://github.com/rulego/streamsql
---

# è‡ªå®šä¹‰å‡½æ•°

StreamSQLæä¾›äº†å¼ºå¤§çš„æ’ä»¶å¼è‡ªå®šä¹‰å‡½æ•°ç³»ç»Ÿï¼Œæ”¯æŒè¿è¡Œæ—¶åŠ¨æ€æ³¨å†Œå‡½æ•°ï¼Œæ— éœ€é‡å¯ç³»ç»Ÿã€‚é€šè¿‡è‡ªå®šä¹‰å‡½æ•°ï¼Œæ‚¨å¯ä»¥æ‰©å±•StreamSQLçš„å¤„ç†èƒ½åŠ›ï¼Œå®ç°ç‰¹å®šçš„ä¸šåŠ¡é€»è¾‘ã€‚

## è‡ªå®šä¹‰å‡½æ•°æ¦‚è¿°

StreamSQLæä¾›äº†å¼ºå¤§çš„è‡ªå®šä¹‰å‡½æ•°æ‰©å±•èƒ½åŠ›ï¼Œå…è®¸ç”¨æˆ·æ ¹æ®ä¸šåŠ¡éœ€æ±‚æ³¨å†Œè‡ªå®šä¹‰å‡½æ•°ã€‚åŸºäºæºç é¡¹ç›®çš„å®é™…å®ç°ï¼Œè‡ªå®šä¹‰å‡½æ•°ç³»ç»Ÿå…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š

### æ ¸å¿ƒç‰¹æ€§

- **æ¨¡å—åŒ–æ¶æ„**ï¼šç»Ÿä¸€çš„èšåˆå‡½æ•°å’Œåˆ†æå‡½æ•°ç®¡ç†
- **è‡ªåŠ¨é€‚é…**ï¼šè‡ªåŠ¨å¤„ç†å‡½æ•°ç±»å‹è½¬æ¢å’Œå‚æ•°éªŒè¯
- **ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„å‚æ•°ç±»å‹æ£€æŸ¥å’Œè½¬æ¢ç³»ç»Ÿ
- **ç®€åŒ–æ‰©å±•**ï¼šç®€å•çš„APIï¼Œå‡ è¡Œä»£ç å³å¯æ³¨å†Œ
- **è¿è¡Œæ—¶ç®¡ç†**ï¼šæ”¯æŒåŠ¨æ€æ³¨å†Œå’Œæ³¨é”€å‡½æ•°

### æ¶æ„å›¾

```mermaid
graph TB
    A[SQLæŸ¥è¯¢] --> B[SQLè§£æå™¨]
    B --> C[å‡½æ•°è¯†åˆ«]
    C --> D{å‡½æ•°ç±»å‹}
    D -->|å†…ç½®å‡½æ•°| E[å†…ç½®å‡½æ•°åº“]
    D -->|è‡ªå®šä¹‰å‡½æ•°| F[è‡ªå®šä¹‰å‡½æ•°æ³¨å†Œè¡¨]
    E --> G[å‡½æ•°æ‰§è¡Œ]
    F --> G
    G --> H[è¿”å›ç»“æœ]
    
    subgraph "è‡ªå®šä¹‰å‡½æ•°ç³»ç»Ÿ"
        I[å‡½æ•°æ³¨å†Œ] --> F
        J[å‡½æ•°æ³¨é”€] --> F
        K[å‡½æ•°æ›´æ–°] --> F
    end
```

## å‡½æ•°ç±»å‹ç³»ç»Ÿ

åŸºäºStreamSQLæºç é¡¹ç›®ï¼Œå‡½æ•°ç³»ç»Ÿæ”¯æŒå¤šç§å‡½æ•°ç±»å‹ï¼Œæ¯ç§ç±»å‹éƒ½æœ‰ç‰¹å®šçš„ä½¿ç”¨åœºæ™¯ï¼š

### å‡½æ•°ç±»å‹è¡¨

| ç±»å‹ | å¸¸é‡ | ç”¨é€” | ç¤ºä¾‹ |
|------|------|------|------|
| **èšåˆå‡½æ•°** | `TypeAggregation` | èšåˆè®¡ç®— | `COUNT()`, `SUM()`, `AVG()` |
| **åˆ†æå‡½æ•°** | `TypeAnalytical` | æ•°æ®åˆ†æ | `ROW_NUMBER()`, `RANK()` |
| **çª—å£å‡½æ•°** | `TypeWindow` | çª—å£æ‰©å±• | `TumblingWindow()`, `SlidingWindow()` |
| **æ•°å­¦å‡½æ•°** | `TypeMath` | æ•°å€¼è®¡ç®— | `ABS()`, `ROUND()`, `SQRT()` |
| **å­—ç¬¦ä¸²å‡½æ•°** | `TypeString` | æ–‡æœ¬å¤„ç† | `UPPER()`, `CONCAT()`, `SUBSTRING()` |
| **è½¬æ¢å‡½æ•°** | `TypeConversion` | ç±»å‹è½¬æ¢ | `CAST()`, `TO_JSON()` |
| **æ—¶é—´å‡½æ•°** | `TypeDateTime` | æ—¶é—´å¤„ç† | `NOW()`, `DATE_FORMAT()` |
| **é€šç”¨å‡½æ•°** | `TypeCustom` | é€šç”¨é€»è¾‘ | è‡ªå®šä¹‰ä¸šåŠ¡å‡½æ•° |

## åŸºç¡€ä½¿ç”¨

### 1. è‡ªå®šä¹‰èšåˆå‡½æ•°

åŸºäºStreamSQLæºç é¡¹ç›®çš„å®é™…å®ç°ï¼Œåˆ›å»ºè‡ªå®šä¹‰èšåˆå‡½æ•°ï¼š

```go
package main

import (
    "github.com/rulego/streamsql/functions"
    "github.com/rulego/streamsql/utils/cast"
)

// è‡ªå®šä¹‰ä¹˜ç§¯èšåˆå‡½æ•°
type CustomProductFunction struct {
    *functions.BaseFunction
    product float64
    first   bool
}

func NewCustomProductFunction() *CustomProductFunction {
    return &CustomProductFunction{
        BaseFunction: functions.NewBaseFunction("product", functions.TypeAggregation, 
            "è‡ªå®šä¹‰èšåˆå‡½æ•°", "è®¡ç®—æ•°å€¼ä¹˜ç§¯", 1, -1),
        product: 1.0,
        first:   true,
    }
}

// å®ç°AggregatorFunctionæ¥å£
func (f *CustomProductFunction) New() functions.AggregatorFunction {
    return &CustomProductFunction{
        BaseFunction: f.BaseFunction,
        product:      1.0,
        first:        true,
    }
}

func (f *CustomProductFunction) Add(value interface{}) {
    if val, err := cast.ToFloat64E(value); err == nil {
        if f.first {
            f.product = val
            f.first = false
        } else {
            f.product *= val
        }
    }
}

func (f *CustomProductFunction) Result() interface{} {
    if f.first {
        return 0.0
    }
    return f.product
}

func (f *CustomProductFunction) Reset() {
    f.product = 1.0
    f.first = true
}

func (f *CustomProductFunction) Clone() functions.AggregatorFunction {
    return &CustomProductFunction{
        BaseFunction: f.BaseFunction,
        product:      f.product,
        first:        f.first,
    }
}

func main() {
    // æ³¨å†Œè‡ªå®šä¹‰èšåˆå‡½æ•°
    productFunc := NewCustomProductFunction()
    functions.RegisterAggregator("product", productFunc)
    
    // ç°åœ¨å¯ä»¥åœ¨SQLä¸­ä½¿ç”¨
    // SELECT deviceId, PRODUCT(value) FROM stream GROUP BY deviceId, TumblingWindow('1m')
}
```

### 2. åœ¨SQLä¸­ä½¿ç”¨

```sql
-- æ³¨å†Œåç«‹å³å¯ç”¨
SELECT deviceId, 
       distance(start_lat, start_lon, end_lat, end_lon) as travel_distance,
       temperature
FROM stream
WHERE travel_distance > 1000  -- è·ç¦»è¶…è¿‡1000ç±³
```

### 3. å‡½æ•°ç®¡ç†

```go
// æ£€æŸ¥å‡½æ•°æ˜¯å¦å­˜åœ¨
if exists := functions.Exists("distance"); exists {
    fmt.Println("å‡½æ•°distanceå·²æ³¨å†Œ")
}

// è·å–å‡½æ•°ä¿¡æ¯
if fn, exists := functions.Get("distance"); exists {
    fmt.Printf("å‡½æ•°ç±»å‹: %s\n", fn.GetType())
    fmt.Printf("å‡½æ•°æè¿°: %s\n", fn.GetDescription())
}

// æ³¨é”€å‡½æ•°
functions.Unregister("distance")

// åˆ—å‡ºæ‰€æœ‰è‡ªå®šä¹‰å‡½æ•°
customFuncs := functions.ListCustomFunctions()
for name, fn := range customFuncs {
    fmt.Printf("å‡½æ•°: %s, ç±»å‹: %s\n", name, fn.GetType())
}
```

## å‡½æ•°å¼€å‘è¯¦æƒ…

### 1. æ•°å­¦å‡½æ•° (TypeMath)

ç”¨äºæ•°å€¼è®¡ç®—å’Œæ•°å­¦è¿ç®—ã€‚

```go
// è®¡ç®—ä¸¤ä¸ªå‘é‡çš„å¤¹è§’
functions.RegisterCustomFunction("vector_angle", functions.TypeMath, 
    "å‘é‡è®¡ç®—", "è®¡ç®—ä¸¤ä¸ªå‘é‡çš„å¤¹è§’ï¼ˆå¼§åº¦ï¼‰", 4, 4,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        x1, _ := functions.ConvertToFloat64(args[0])
        y1, _ := functions.ConvertToFloat64(args[1])
        x2, _ := functions.ConvertToFloat64(args[2])
        y2, _ := functions.ConvertToFloat64(args[3])
        
        // è®¡ç®—å‘é‡å¤¹è§’
        dot := x1*x2 + y1*y2
        mag1 := math.Sqrt(x1*x1 + y1*y1)
        mag2 := math.Sqrt(x2*x2 + y2*y2)
        
        if mag1 == 0 || mag2 == 0 {
            return 0.0, nil
        }
        
        angle := math.Acos(dot / (mag1 * mag2))
        return angle, nil
    })
```

```sql
-- ä½¿ç”¨æ•°å­¦å‡½æ•°
SELECT deviceId,
       vector_angle(acc_x, acc_y, gravity_x, gravity_y) as tilt_angle,
       temperature
FROM stream
WHERE tilt_angle > 0.5  -- å€¾æ–œè§’åº¦å¤§äº0.5å¼§åº¦
```

### 2. å­—ç¬¦ä¸²å‡½æ•° (TypeString)

ç”¨äºæ–‡æœ¬å¤„ç†å’Œå­—ç¬¦ä¸²æ“ä½œã€‚

```go
// æå–è®¾å¤‡ç±»å‹
functions.RegisterCustomFunction("extract_device_type", functions.TypeString,
    "æ–‡æœ¬å¤„ç†", "ä»è®¾å¤‡IDä¸­æå–è®¾å¤‡ç±»å‹", 1, 1,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        deviceId, err := functions.ConvertToString(args[0])
        if err != nil {
            return "", err
        }
        
        // å‡è®¾è®¾å¤‡IDæ ¼å¼ï¼šTYPE_LOCATION_NUMBER
        parts := strings.Split(deviceId, "_")
        if len(parts) >= 1 {
            return strings.ToUpper(parts[0]), nil
        }
        
        return "UNKNOWN", nil
    })

// æ ¼å¼åŒ–ä¼ æ„Ÿå™¨è¯»æ•°
functions.RegisterCustomFunction("format_reading", functions.TypeString,
    "æ•°æ®æ ¼å¼åŒ–", "æ ¼å¼åŒ–ä¼ æ„Ÿå™¨è¯»æ•°", 2, 3,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        value, err := functions.ConvertToFloat64(args[0])
        if err != nil {
            return "", err
        }
        
        unit, err := functions.ConvertToString(args[1])
        if err != nil {
            return "", err
        }
        
        precision := 2
        if len(args) > 2 {
            if p, err := functions.ConvertToInt(args[2]); err == nil {
                precision = p
            }
        }
        
        format := fmt.Sprintf("%%.%df %s", precision, unit)
        return fmt.Sprintf(format, value), nil
    })
```

```sql
-- ä½¿ç”¨å­—ç¬¦ä¸²å‡½æ•°
SELECT deviceId,
       extract_device_type(deviceId) as device_type,
       format_reading(temperature, 'Â°C', 1) as temp_display,
       format_reading(humidity, '%', 0) as humidity_display
FROM stream
```

### 3. è½¬æ¢å‡½æ•° (TypeConversion)

ç”¨äºæ•°æ®ç±»å‹è½¬æ¢å’Œæ ¼å¼å˜æ¢ï¼š

```go
// æ¸©åº¦å•ä½è½¬æ¢
functions.RegisterCustomFunction("temp_convert", functions.TypeConversion,
    "å•ä½è½¬æ¢", "æ¸©åº¦å•ä½è½¬æ¢", 3, 3,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        value, err := functions.ConvertToFloat64(args[0])
        if err != nil {
            return nil, err
        }
        
        fromUnit, err := functions.ConvertToString(args[1])
        if err != nil {
            return nil, err
        }
        
        toUnit, err := functions.ConvertToString(args[2])
        if err != nil {
            return nil, err
        }
        
        // å…ˆè½¬æ¢åˆ°æ‘„æ°åº¦
        var celsius float64
        switch strings.ToLower(fromUnit) {
        case "c", "celsius":
            celsius = value
        case "f", "fahrenheit":
            celsius = (value - 32) * 5 / 9
        case "k", "kelvin":
            celsius = value - 273.15
        default:
            return nil, fmt.Errorf("ä¸æ”¯æŒçš„æºæ¸©åº¦å•ä½: %s", fromUnit)
        }
        
        // ä»æ‘„æ°åº¦è½¬æ¢åˆ°ç›®æ ‡å•ä½
        switch strings.ToLower(toUnit) {
        case "c", "celsius":
            return celsius, nil
        case "f", "fahrenheit":
            return celsius*9/5 + 32, nil
        case "k", "kelvin":
            return celsius + 273.15, nil
        default:
            return nil, fmt.Errorf("ä¸æ”¯æŒçš„ç›®æ ‡æ¸©åº¦å•ä½: %s", toUnit)
        }
    })
```

```sql
-- ä½¿ç”¨è½¬æ¢å‡½æ•°
SELECT deviceId,
       temperature,
       temp_convert(temperature, 'C', 'F') as temp_fahrenheit,
       temp_convert(temperature, 'C', 'K') as temp_kelvin
FROM stream
```

### 4. æ—¶é—´å‡½æ•° (TypeDateTime)

ç”¨äºæ—¶é—´å¤„ç†å’Œæ—¥æœŸè®¡ç®—ï¼š

```go
// è®¡ç®—æ—¶é—´å·®
functions.RegisterCustomFunction("time_diff_minutes", functions.TypeDateTime,
    "æ—¶é—´è®¡ç®—", "è®¡ç®—ä¸¤ä¸ªæ—¶é—´æˆ³ä¹‹é—´çš„åˆ†é’Ÿå·®", 2, 2,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        t1, err := functions.ConvertToTime(args[0])
        if err != nil {
            return nil, err
        }
        
        t2, err := functions.ConvertToTime(args[1])
        if err != nil {
            return nil, err
        }
        
        diff := t2.Sub(t1)
        minutes := diff.Minutes()
        
        return minutes, nil
    })

// å·¥ä½œæ—¥åˆ¤æ–­
functions.RegisterCustomFunction("is_workday", functions.TypeDateTime,
    "æ—¶é—´åˆ¤æ–­", "åˆ¤æ–­ç»™å®šæ—¶é—´æ˜¯å¦ä¸ºå·¥ä½œæ—¥", 1, 1,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        t, err := functions.ConvertToTime(args[0])
        if err != nil {
            return nil, err
        }
        
        weekday := t.Weekday()
        isWorkday := weekday >= time.Monday && weekday <= time.Friday
        
        return isWorkday, nil
    })
```

```sql
-- ä½¿ç”¨æ—¶é—´å‡½æ•°
SELECT deviceId,
       timestamp,
       is_workday(timestamp) as is_business_hours,
       time_diff_minutes(last_maintenance, timestamp) as minutes_since_maintenance
FROM stream
WHERE is_business_hours = true
```

### 5. èšåˆå‡½æ•° (TypeAggregation)

ç”¨äºè‡ªå®šä¹‰èšåˆè®¡ç®—ï¼š

```go
// åŠ æƒå¹³å‡å€¼
functions.RegisterCustomFunction("weighted_avg", functions.TypeAggregation,
    "èšåˆè®¡ç®—", "è®¡ç®—åŠ æƒå¹³å‡å€¼", 2, 2,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        values, err := functions.ConvertToFloat64Array(args[0])
        if err != nil {
            return nil, err
        }
        
        weights, err := functions.ConvertToFloat64Array(args[1])
        if err != nil {
            return nil, err
        }
        
        if len(values) != len(weights) {
            return nil, fmt.Errorf("å€¼å’Œæƒé‡æ•°ç»„é•¿åº¦ä¸åŒ¹é…")
        }
        
        var weightedSum, totalWeight float64
        for i := 0; i < len(values); i++ {
            weightedSum += values[i] * weights[i]
            totalWeight += weights[i]
        }
        
        if totalWeight == 0 {
            return 0.0, nil
        }
        
        return weightedSum / totalWeight, nil
    })
```

```sql
-- ä½¿ç”¨èšåˆå‡½æ•°ï¼ˆéœ€è¦åœ¨çª—å£ä¸­ä½¿ç”¨ï¼‰
SELECT deviceId,
       weighted_avg(temperature, reliability_score) as reliable_avg_temp
FROM stream
GROUP BY deviceId, TumblingWindow('5m')
```

### 6. åˆ†æå‡½æ•° (TypeAnalytical)

ç”¨äºæ•°æ®åˆ†æå’Œç»Ÿè®¡è®¡ç®—ï¼š

```go
// å¼‚å¸¸æ£€æµ‹
functions.RegisterCustomFunction("detect_anomaly", functions.TypeAnalytical,
    "å¼‚å¸¸æ£€æµ‹", "åŸºäºZ-Scoreæ£€æµ‹å¼‚å¸¸", 2, 3,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        value, err := functions.ConvertToFloat64(args[0])
        if err != nil {
            return nil, err
        }
        
        mean, err := functions.ConvertToFloat64(args[1])
        if err != nil {
            return nil, err
        }
        
        threshold := 3.0 // é»˜è®¤3å€æ ‡å‡†å·®
        if len(args) > 2 {
            if t, err := functions.ConvertToFloat64(args[2]); err == nil {
                threshold = t
            }
        }
        
        // è¿™é‡Œéœ€è¦æ ‡å‡†å·®ï¼Œå®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦ä»ä¸Šä¸‹æ–‡è·å–
        stddev := 1.0 // ç®€åŒ–ç¤ºä¾‹
        
        zScore := math.Abs(value-mean) / stddev
        isAnomaly := zScore > threshold
        
        return map[string]interface{}{
            "is_anomaly": isAnomaly,
            "z_score":    zScore,
            "threshold":  threshold,
        }, nil
    })
```

```sql
-- ä½¿ç”¨åˆ†æå‡½æ•°
SELECT deviceId,
       temperature,
       detect_anomaly(temperature, avg_temp, 2.5) as anomaly_info
FROM stream
GROUP BY deviceId, SlidingWindow('10m', '1m')
```

## é«˜çº§ç‰¹æ€§

### 1. ä¸Šä¸‹æ–‡ä½¿ç”¨

FunctionContextæä¾›äº†é¢å¤–çš„æ‰§è¡Œä¸Šä¸‹æ–‡ä¿¡æ¯ï¼š

```go
functions.RegisterCustomFunction("context_example", functions.TypeCustom,
    "ä¸Šä¸‹æ–‡ç¤ºä¾‹", "å±•ç¤ºå¦‚ä½•ä½¿ç”¨å‡½æ•°ä¸Šä¸‹æ–‡", 1, 1,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        // è·å–å½“å‰å¤„ç†çš„æ•°æ®è¡Œï¼ˆå¦‚æœåœ¨æµå¤„ç†ä¸­ï¼‰
        if ctx.CurrentRow != nil {
            // å¯ä»¥è®¿é—®å½“å‰è¡Œçš„å…¶ä»–å­—æ®µ
            if deviceId, exists := ctx.CurrentRow["deviceId"]; exists {
                fmt.Printf("å½“å‰å¤„ç†è®¾å¤‡: %v\n", deviceId)
            }
        }
        
        // è·å–çª—å£ä¿¡æ¯ï¼ˆå¦‚æœåœ¨çª—å£èšåˆä¸­ï¼‰
        if ctx.WindowInfo != nil {
            fmt.Printf("çª—å£å¼€å§‹æ—¶é—´: %v\n", ctx.WindowInfo.StartTime)
            fmt.Printf("çª—å£ç»“æŸæ—¶é—´: %v\n", ctx.WindowInfo.EndTime)
        }
        
        // æ‰§è¡Œè‡ªå®šä¹‰é€»è¾‘
        input, _ := functions.ConvertToString(args[0])
        return fmt.Sprintf("å¤„ç†ç»“æœ: %s", input), nil
    })
```

### 2. é”™è¯¯å¤„ç†

å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼š

```go
functions.RegisterCustomFunction("safe_divide", functions.TypeMath,
    "å®‰å…¨é™¤æ³•", "å®‰å…¨çš„é™¤æ³•è¿ç®—ï¼Œé¿å…é™¤é›¶é”™è¯¯", 2, 2,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        dividend, err := functions.ConvertToFloat64(args[0])
        if err != nil {
            return nil, fmt.Errorf("è¢«é™¤æ•°è½¬æ¢å¤±è´¥: %w", err)
        }
        
        divisor, err := functions.ConvertToFloat64(args[1])
        if err != nil {
            return nil, fmt.Errorf("é™¤æ•°è½¬æ¢å¤±è´¥: %w", err)
        }
        
        if divisor == 0 {
            return nil, fmt.Errorf("é™¤æ•°ä¸èƒ½ä¸ºé›¶")
        }
        
        return dividend / divisor, nil
    })
```

### 3. å‚æ•°éªŒè¯

ä½¿ç”¨å†…ç½®çš„å‚æ•°éªŒè¯åŠŸèƒ½ï¼š

```go
functions.RegisterCustomFunction("validate_range", functions.TypeCustom,
    "èŒƒå›´éªŒè¯", "éªŒè¯æ•°å€¼æ˜¯å¦åœ¨æŒ‡å®šèŒƒå›´å†…", 3, 3,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        // ä½¿ç”¨å†…ç½®è½¬æ¢å‡½æ•°ï¼Œè‡ªåŠ¨å¤„ç†é”™è¯¯
        value, err := functions.ConvertToFloat64(args[0])
        if err != nil {
            return nil, err
        }
        
        min, err := functions.ConvertToFloat64(args[1])
        if err != nil {
            return nil, err
        }
        
        max, err := functions.ConvertToFloat64(args[2])
        if err != nil {
            return nil, err
        }
        
        if min > max {
            return nil, fmt.Errorf("æœ€å°å€¼ %.2f ä¸èƒ½å¤§äºæœ€å¤§å€¼ %.2f", min, max)
        }
        
        inRange := value >= min && value <= max
        return map[string]interface{}{
            "in_range": inRange,
            "value":    value,
            "min":      min,
            "max":      max,
        }, nil
    })
```

## å®é™…åº”ç”¨æ¡ˆä¾‹

### 1. IoTè®¾å¤‡ç›‘æ§

```go
// è®¾å¤‡å¥åº·çŠ¶æ€è¯„ä¼°
functions.RegisterCustomFunction("device_health", functions.TypeAnalytical,
    "è®¾å¤‡ç›‘æ§", "è¯„ä¼°è®¾å¤‡å¥åº·çŠ¶æ€", 4, 4,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        temperature, _ := functions.ConvertToFloat64(args[0])
        voltage, _ := functions.ConvertToFloat64(args[1])
        signalStrength, _ := functions.ConvertToFloat64(args[2])
        errorCount, _ := functions.ConvertToInt(args[3])
        
        var score int = 100
        var issues []string
        
        // æ¸©åº¦æ£€æµ‹
        if temperature > 70 {
            score -= 30
            issues = append(issues, "é«˜æ¸©å‘Šè­¦")
        } else if temperature > 60 {
            score -= 15
            issues = append(issues, "æ¸©åº¦åé«˜")
        }
        
        // ç”µå‹æ£€æµ‹
        if voltage < 3.0 {
            score -= 25
            issues = append(issues, "ç”µå‹ä¸è¶³")
        } else if voltage < 3.3 {
            score -= 10
            issues = append(issues, "ç”µå‹åä½")
        }
        
        // ä¿¡å·å¼ºåº¦æ£€æµ‹
        if signalStrength < -80 {
            score -= 20
            issues = append(issues, "ä¿¡å·å¼±")
        }
        
        // é”™è¯¯è®¡æ•°æ£€æŸ¥
        if errorCount > 10 {
            score -= 30
            issues = append(issues, "é”™è¯¯é¢‘å‘")
        } else if errorCount > 5 {
            score -= 15
            issues = append(issues, "é”™è¯¯åå¤š")
        }
        
        var status string
        if score >= 90 {
            status = "ä¼˜ç§€"
        } else if score >= 70 {
            status = "è‰¯å¥½"
        } else if score >= 50 {
            status = "ä¸€èˆ¬"
        } else {
            status = "æ•…éšœ"
        }
        
        return map[string]interface{}{
            "score":  score,
            "status": status,
            "issues": issues,
        }, nil
    })
```

```sql
-- è®¾å¤‡å¥åº·ç›‘æ§
SELECT deviceId,
       device_health(temperature, voltage, signal_strength, error_count) as health,
       AVG(temperature) as avg_temp,
       COUNT(*) as message_count
FROM stream
GROUP BY deviceId, TumblingWindow('5m')
HAVING JSON_EXTRACT(health, '$.score') < 70  -- å¥åº·åˆ†æ•°ä½äº70çš„è®¾å¤‡
```

### 2. é‡‘èæ•°æ®åˆ†æ

```go
// æŠ€æœ¯æŒ‡æ ‡è®¡ç®—
functions.RegisterCustomFunction("rsi", functions.TypeAnalytical,
    "æŠ€æœ¯åˆ†æ", "è®¡ç®—ç›¸å¯¹å¼ºå¼±æŒ‡æ•°(RSI)", 2, 2,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        prices, err := functions.ConvertToFloat64Array(args[0])
        if err != nil {
            return nil, err
        }
        
        period, err := functions.ConvertToInt(args[1])
        if err != nil {
            return nil, err
        }
        
        if len(prices) < period+1 {
            return nil, fmt.Errorf("æ•°æ®ä¸è¶³ï¼Œéœ€è¦è‡³å°‘ %d ä¸ªä»·æ ¼ç‚¹", period+1)
        }
        
        var gains, losses []float64
        for i := 1; i < len(prices); i++ {
            change := prices[i] - prices[i-1]
            if change > 0 {
                gains = append(gains, change)
                losses = append(losses, 0)
            } else {
                gains = append(gains, 0)
                losses = append(losses, -change)
            }
        }
        
        // è®¡ç®—å¹³å‡æ¶¨è·Œå¹…
        var avgGain, avgLoss float64
        for i := 0; i < period; i++ {
            avgGain += gains[i]
            avgLoss += losses[i]
        }
        avgGain /= float64(period)
        avgLoss /= float64(period)
        
        if avgLoss == 0 {
            return 100.0, nil // é¿å…é™¤é›¶
        }
        
        rs := avgGain / avgLoss
        rsi := 100 - (100 / (1 + rs))
        
        return rsi, nil
    })
```

### 3. ç”¨æˆ·è¡Œä¸ºåˆ†æ

```go
// ç”¨æˆ·æ´»è·ƒåº¦è¯„ä¼°
functions.RegisterCustomFunction("user_engagement", functions.TypeAnalytical,
    "ç”¨æˆ·åˆ†æ", "è®¡ç®—ç”¨æˆ·å‚ä¸åº¦è¯„åˆ†", 5, 5,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        pageViews, _ := functions.ConvertToInt(args[0])
        timeSpent, _ := functions.ConvertToFloat64(args[1])  // åˆ†é’Ÿ
        interactions, _ := functions.ConvertToInt(args[2])
        bounceRate, _ := functions.ConvertToFloat64(args[3]) // 0-1
        returnVisits, _ := functions.ConvertToInt(args[4])
        
        // è®¡ç®—å„é¡¹è¯„åˆ†
        pageScore := math.Min(float64(pageViews)*2, 20)
        timeScore := math.Min(timeSpent/10*15, 25)
        interactionScore := math.Min(float64(interactions)*3, 25)
        retentionScore := (1-bounceRate)*15 + math.Min(float64(returnVisits)*2, 15)
        
        totalScore := pageScore + timeScore + interactionScore + retentionScore
        
        var level string
        if totalScore >= 80 {
            level = "é«˜åº¦æ´»è·ƒ"
        } else if totalScore >= 60 {
            level = "ä¸­åº¦æ´»è·ƒ"
        } else if totalScore >= 40 {
            level = "ä½åº¦æ´»è·ƒ"
        } else {
            level = "ä¸æ´»è·ƒ"
        }
        
        return map[string]interface{}{
            "score":            totalScore,
            "level":            level,
            "page_score":       pageScore,
            "time_score":       timeScore,
            "interaction_score": interactionScore,
            "retention_score":  retentionScore,
        }, nil
    })
```

## æ€§èƒ½ä¼˜åŒ–

### 1. å‡½æ•°ç¼“å­˜

å¯¹äºè®¡ç®—å¼€é”€å¤§çš„å‡½æ•°ï¼Œè€ƒè™‘å®ç°ç¼“å­˜

```go
var calculationCache = make(map[string]interface{})
var cacheMutex sync.RWMutex

functions.RegisterCustomFunction("expensive_calculation", functions.TypeMath,
    "å¤æ‚è®¡ç®—", "å¸¦ç¼“å­˜çš„å¤æ‚è®¡ç®—", 1, 1,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        input, err := functions.ConvertToString(args[0])
        if err != nil {
            return nil, err
        }
        
        // ç”Ÿæˆç¼“å­˜é”®
        cacheKey := fmt.Sprintf("calc_%s", input)
        
        // æ£€æŸ¥ç¼“å­˜
        cacheMutex.RLock()
        if result, exists := calculationCache[cacheKey]; exists {
            cacheMutex.RUnlock()
            return result, nil
        }
        cacheMutex.RUnlock()
        
        // æ‰§è¡Œå¤æ‚è®¡ç®—
        time.Sleep(100 * time.Millisecond) // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
        result := fmt.Sprintf("processed_%s", input)
        
        // å­˜å…¥ç¼“å­˜
        cacheMutex.Lock()
        calculationCache[cacheKey] = result
        cacheMutex.Unlock()
        
        return result, nil
    })
```

### 2. å‚æ•°é¢„å¤„ç†

æå‰éªŒè¯å’Œè½¬æ¢å‚æ•°ï¼Œé¿å…é‡å¤å¤„ç†

```go
functions.RegisterCustomFunction("optimized_function", functions.TypeMath,
    "ä¼˜åŒ–å‡½æ•°", "å‚æ•°é¢„å¤„ç†ä¼˜åŒ–", 2, 2,
    func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
        // æ‰¹é‡è½¬æ¢å‚æ•°ï¼Œå‡å°‘é‡å¤è°ƒç”¨
        var values [2]float64
        for i, arg := range args {
            val, err := functions.ConvertToFloat64(arg)
            if err != nil {
                return nil, fmt.Errorf("å‚æ•° %d è½¬æ¢å¤±è´¥: %w", i+1, err)
            }
            values[i] = val
        }
        
        // æ‰§è¡Œè®¡ç®—
        result := values[0] * values[1]
        return result, nil
    })
```

## æœ€ä½³å®è·µ

### 1. å‡½æ•°å‘½å

- ä½¿ç”¨æ¸…æ™°ã€æè¿°æ€§çš„åç§°
- éµå¾ªsnake_caseå‘½åè§„èŒƒ
- é¿å…ä¸å†…ç½®å‡½æ•°å†²çª

```go
// å¥½çš„å‘½å
functions.RegisterCustomFunction("calculate_distance", ...)
functions.RegisterCustomFunction("validate_email", ...)
functions.RegisterCustomFunction("format_currency", ...)

// é¿å…çš„å‘½å
functions.RegisterCustomFunction("func1", ...)      // ä¸å…·æè¿°æ€§
functions.RegisterCustomFunction("AVG", ...)        // ä¸å†…ç½®å‡½æ•°å†²çª
functions.RegisterCustomFunction("calculateDistance", ...) // ä¸ç¬¦åˆè§„èŒƒ
```

### 2. é”™è¯¯å¤„ç†

- æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯
- ä½¿ç”¨ç±»å‹å®‰å…¨çš„å‚æ•°è½¬æ¢
- é¿å…panicï¼Œæ€»æ˜¯è¿”å›error

```go
// å¥½çš„é”™è¯¯å¤„ç†
func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
    if len(args) < 2 {
        return nil, fmt.Errorf("å‡½æ•°éœ€è¦è‡³å°‘ 2 ä¸ªå‚æ•°ï¼Œä½†åªæä¾› %d", len(args))
    }
    
    value, err := functions.ConvertToFloat64(args[0])
    if err != nil {
        return nil, fmt.Errorf("ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æ˜¯æ•°å­—ç±»å‹: %w", err)
    }
    
    if value < 0 {
        return nil, fmt.Errorf("å‚æ•°å€¼ä¸èƒ½ä¸ºè´Ÿæ•°: %.2f", value)
    }
    
    // å¤„ç†é€»è¾‘...
    return result, nil
}
```

### 3. æ–‡æ¡£å’Œæµ‹è¯•

ä¸ºè‡ªå®šä¹‰å‡½æ•°ç¼–å†™æµ‹è¯•

```go
func TestCustomFunction(t *testing.T) {
    // æ³¨å†Œæµ‹è¯•å‡½æ•°
    err := functions.RegisterCustomFunction("test_func", functions.TypeMath,
        "æµ‹è¯•", "æµ‹è¯•å‡½æ•°", 1, 1,
        func(ctx *functions.FunctionContext, args []interface{}) (interface{}, error) {
            val, _ := functions.ConvertToFloat64(args[0])
            return val * 2, nil
        })
    require.NoError(t, err)
    defer functions.Unregister("test_func")
    
    // æµ‹è¯•å‡½æ•°æ‰§è¡Œ
    fn, exists := functions.Get("test_func")
    require.True(t, exists)
    
    result, err := fn.Execute(&functions.FunctionContext{}, []interface{}{5.0})
    require.NoError(t, err)
    assert.Equal(t, 10.0, result)
}
```

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

#### 1. å‡½æ•°æ³¨å†Œå¤±è´¥
```go
// æ£€æŸ¥å‡½æ•°åæ˜¯å¦å·²å­˜åœ¨
if functions.Exists("my_function") {
    functions.Unregister("my_function")  // å…ˆæ³¨é”€å†æ³¨å†Œ
}
err := functions.RegisterCustomFunction("my_function", ...)
```

#### 2. å‚æ•°ç±»å‹é”™è¯¯
```go
// ä½¿ç”¨å®‰å…¨çš„ç±»å‹è½¬æ¢
value, err := functions.ConvertToFloat64(args[0])
if err != nil {
    return nil, fmt.Errorf("å‚æ•°ç±»å‹é”™è¯¯: %w", err)
}
```

#### 3. å‡½æ•°åœ¨SQLä¸­ä¸å¯ç”¨
```sql
-- ç¡®ä¿å‡½æ•°å·²æ³¨å†ŒæˆåŠŸ
-- æ£€æŸ¥å‡½æ•°åæ‹¼å†™
-- éªŒè¯å‚æ•°æ•°é‡æ˜¯å¦æ­£ç¡®
SELECT custom_function(param1, param2) FROM stream
```

## ä¸‹ä¸€æ­¥

ç°åœ¨æ‚¨å·²ç»æŒæ¡äº†è‡ªå®šä¹‰å‡½æ•°çš„å¼€å‘å’Œä½¿ç”¨ï¼Œå»ºè®®ç»§ç»­å­¦ä¹ ï¼š

- ğŸ’¡ [ç¤ºä¾‹é›†åˆ](/pages/streamsql-examples/) - æŸ¥çœ‹æ›´å¤šè‡ªå®šä¹‰å‡½æ•°åº”ç”¨æ¡ˆä¾‹
- ğŸ“š [APIå‚è€ƒ](/pages/streamsql-api/) - å®Œæ•´çš„APIæ–‡æ¡£
- ğŸ“– [æœ€ä½³å®è·µ](/pages/streamsql-best-practices/) - ç”Ÿäº§ç¯å¢ƒä½¿ç”¨å»ºè®®
- ğŸ”™ [å¿«é€Ÿå¼€å§‹](/pages/streamsql-quickstart/) - å›é¡¾åŸºç¡€ç”¨æ³•

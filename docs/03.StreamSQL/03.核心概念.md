---
title: 核心概念
date: 2024-01-15 10:03:00
permalink: /pages/streamsql/03/
article: false
author: 
  name: StreamSQL
  link: https://github.com/rulego/streamsql
---

# 核心概念

理解StreamSQL的核心概念是高效使用它的关键。本章将详细介绍流处理、窗口、聚合等重要概念?

## 流处理基础

### 什么是数据?

数据流（Stream）是一系列连续产生的数据记录，具有以下特征?

- **无界?*：数据持续不断地产生，没有明确的结束
- **时序?*：数据按时间顺序到达
- **实时?*：需要快速处理，不能等待所有数?
- **不可变?*：历史数据不可修?

```mermaid
graph LR
    A[传感?] --> D[数据流]
    B[传感?] --> D
    C[传感?] --> D
    D --> E[StreamSQL]
    E --> F[实时结果]
```

### ?vs 批处?

| 特征 | 流处?| 批处?|
|------|--------|--------|
| **数据边界** | 无界 | 有界 |
| **处理延迟** | 毫秒?| 分钟/小时?|
| **数据完整?* | 近似结果 | 精确结果 |
| **资源使用** | 持续占用 | 周期性占?|
| **应用场景** | 实时监控、告?| 报表、分?|

### 流处理模?

StreamSQL采用**微批处理**模型?

```mermaid
graph TB
    A[连续数据流] --> B[缓冲区]
    B --> C[微批次]
    C --> D[SQL处理]
    D --> E[结果输出]
    
    subgraph "时间窗口"
        F[窗口1] --> G[窗口2] --> H[窗口3]
    end
    
    C --> F
```

## 时间语义

### 时间类型

StreamSQL支持两种时间概念?

#### 1. 事件时间 (Event Time)
- 数据产生时的真实时间
- 使用 `with (TIMESTAMP='field_name')` 指定
- 适用于需要精确时序的场景

```sql
SELECT deviceId, AVG(temperature) 
FROM stream 
GROUP BY deviceId, TumblingWindow('1m')
WITH (TIMESTAMP='event_time')
```

#### 2. 处理时间 (Processing Time)
- 数据到达处理系统的时?
- 默认使用系统当前时间
- 处理简单，但可能不准确

```sql
-- 使用处理时间（默认）
SELECT deviceId, AVG(temperature) 
FROM stream 
GROUP BY deviceId, TumblingWindow('1m')
```

### 时间格式

支持多种时间单位?

```sql
-- 时间单位配置
WITH (TIMEUNIT='ss')  -- ?
WITH (TIMEUNIT='ms')  -- 毫秒  
WITH (TIMEUNIT='mi')  -- 分钟
WITH (TIMEUNIT='hh')  -- 小时
WITH (TIMEUNIT='dd')  -- ?
```

## 窗口概念

窗口是流处理中的核心概念，用于将无界流分割成有界的数据集进行聚合操作?

### 窗口类型

#### 1. 滚动窗口 (Tumbling Window)

固定大小、无重叠的时间窗口：

```mermaid
gantt
    title 滚动窗口示例
    dateFormat X
    axisFormat %H:%M
    
    section 窗口1
    10:00-10:05    :active, w1, 0, 5
    section 窗口2  
    10:05-10:10    :active, w2, 5, 10
    section 窗口3
    10:10-10:15    :active, w3, 10, 15
```

```sql
-- ?分钟计算一次平均?
SELECT AVG(temperature) 
FROM stream 
GROUP BY TumblingWindow('5m')
```

**特点**?
- 每条数据只属于一个窗?
- 窗口之间无重?
- 适合周期性统?

#### 2. 滑动窗口 (Sliding Window)

固定大小、有重叠的时间窗口：

```mermaid
gantt
    title 滑动窗口示例
    dateFormat X
    axisFormat %H:%M
    
    section 窗口1
    10:00-10:05    :active, w1, 0, 5
    section 窗口2
    10:02-10:07    :active, w2, 2, 7
    section 窗口3
    10:04-10:09    :active, w3, 4, 9
```

```sql
-- 5分钟窗口，每2分钟滑动一?
SELECT AVG(temperature) 
FROM stream 
GROUP BY SlidingWindow('5m', '2m')
```

**特点**?
- 每条数据可能属于多个窗口
- 提供更平滑的分析结果
- 计算开销相对较大

#### 3. 计数窗口 (Counting Window)

基于数据条数的窗口：

```sql
-- ?00条数据计算一?
SELECT AVG(temperature) 
FROM stream 
GROUP BY CountingWindow(100)
```

**特点**?
- 基于数据量而非时间
- 窗口大小固定
- 适合数据量稳定的场景

#### 4. 会话窗口 (Session Window)

基于数据活跃度的动态窗口：

```sql
-- 超时5分钟关闭会话
SELECT user_id, COUNT(*) 
FROM stream 
GROUP BY user_id, SessionWindow('5m')
```

**特点**?
- 窗口大小动态变?
- 基于数据间隔判断会话
- 适合用户行为分析

### 窗口生命周期

```mermaid
stateDiagram-v2
    [*] --> 创建: 首个数据到达
    创建 --> 累积: 持续接收数据
    累积 --> 累积: 数据在窗口范围内
    累积 --> 触发: 窗口条件满足
    触发 --> 输出: 执行聚合计算
    输出 --> 关闭: 清理资源
    关闭 --> [*]
```

## 聚合操作

### 聚合函数分类

#### 1. 统计聚合
```sql
SELECT deviceId,
       COUNT(*) as data_count,           -- 计数
       SUM(temperature) as total_temp,   -- 求和
       AVG(temperature) as avg_temp,     -- 平均?
       MIN(temperature) as min_temp,     -- 最小?
       MAX(temperature) as max_temp      -- 最大?
FROM stream 
GROUP BY deviceId, TumblingWindow('1m')
```

#### 2. 高级统计
```sql
SELECT deviceId,
       STDDEV(temperature) as std_temp,      -- 标准?
       MEDIAN(temperature) as med_temp,      -- 中位?
       PERCENTILE(temperature, 0.95) as p95 -- 95分位?
FROM stream 
GROUP BY deviceId, TumblingWindow('1m')
```

#### 3. 集合聚合
```sql
SELECT deviceId,
       COLLECT(temperature) as temp_list,     -- 收集到数?
       LAST_VALUE(temperature) as last_temp   -- 最后一个?
FROM stream 
GROUP BY deviceId, TumblingWindow('1m')
```

### 聚合状态管?

StreamSQL自动管理聚合状态：

```mermaid
graph TB
    A[新数据] --> B[状态更新]
    B --> C[检查触发条件]
    C --> D{是否触发?}
    D -->|是| E[计算结果]
    D -->|否| F[继续累积]
    E --> G[清理状态]
    F --> B
```

## 表达式系?

### 算术表达?
```sql
SELECT deviceId,
       temperature * 1.8 + 32 as fahrenheit,  -- 温度转换
       (humidity + moisture) / 2 as avg_wet   -- 平均湿度
FROM stream
```

### 逻辑表达?
```sql
SELECT deviceId,
       temperature > 30 AND humidity > 80 as alert_condition
FROM stream
WHERE temperature IS NOT NULL
```

### 字符串表达式
```sql
SELECT deviceId,
       CONCAT(deviceId, '_', status) as device_status,
       UPPER(location) as location_upper
FROM stream
```

### 条件表达?
```sql
SELECT deviceId,
       CASE 
           WHEN temperature > 35 THEN '高温'
           WHEN temperature > 25 THEN '正常'
           ELSE '低温'
       END as temp_level
FROM stream
```

## 数据类型

### 基本类型

| 类型 | 说明 | 示例 |
|------|------|------|
| **数?* | 整数、浮点数 | `25`, `3.14`, `-10` |
| **字符?* | 文本数据 | `"sensor001"`, `'active'` |
| **布尔** | 逻辑?| `true`, `false` |
| **时间** | 时间?| `time.Now()` |

### 复合类型

```go
// 支持嵌套结构
data := map[string]interface{}{
    "deviceId": "sensor001",
    "location": map[string]interface{}{
        "building": "A",
        "floor": 3,
    },
    "readings": []float64{23.5, 24.1, 25.2},
}
```

### 类型转换

StreamSQL提供自动类型转换?

```sql
-- 自动转换字符串到数字
SELECT deviceId, temperature + '5' as adjusted_temp
FROM stream

-- 显式转换
SELECT deviceId, CAST(temperature AS STRING) as temp_str
FROM stream
```

## 执行模型

### 数据流向

```mermaid
graph TB
    A[原始数据] --> B[过滤 WHERE]
    B --> C[窗口分组]
    C --> D[聚合计算]
    D --> E[投影 SELECT]
    E --> F[过滤 HAVING]
    F --> G[排序 ORDER BY]
    G --> H[限制 LIMIT]
    H --> I[结果输出]
```

### 处理阶段

1. **解析阶段**：SQL语句解析为抽象语法树
2. **规划阶段**：生成执行计划和配置
3. **执行阶段**：创建流处理管道
4. **运行阶段**：持续处理数据流

### 资源管理

```go
// 正确的资源管?
ssql := streamsql.New()
defer ssql.Stop()  // 确保资源释放

// 错误处理
err := ssql.Execute(sql)
if err != nil {
    log.Printf("执行失败: %v", err)
    return
}
```

## 性能考虑

### 内存使用

- **窗口大小**：较大窗口占用更多内?
- **聚合状?*：复杂聚合需要更多状态存?
- **数据类型**：避免不必要的大型对?

### 计算复杂?

- **滑动窗口** > **滚动窗口** > **无窗?*
- **复杂表达?* > **简单表达式**
- **多重GROUP BY** > **单一GROUP BY**

### 优化建议

1. **合理选择窗口类型**：根据业务需求选择最适合的窗?
2. **避免过复杂的表达?*：将复杂逻辑拆分到多个步?
3. **使用合适的数据类型**：避免精度损失和类型转换开销
4. **设置合理的窗口大?*：平衡准确性和性能

## 下一?

现在您已经理解了StreamSQL的核心概念，可以继续学习?

- 📚 [SQL参考](../04.SQL参?) - 完整语法手册
- 🪟 [窗口函数](../05.窗口函数/) - 窗口函数详解
- 🔧 [自定义函数](../06.自定义函?) - 扩展处理能力
- 💡 [示例集合](../07.示例/) - 实际应用案例

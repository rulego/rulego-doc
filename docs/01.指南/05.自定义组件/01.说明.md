---
title: 自定义组件概述
article: false
author: 
  name: rulego
  link: https://github.com/rulego/rulego
date: 2023-09-13 15:24:41
permalink: /pages/caed1b/
---

你可以把你的业务逻辑或者通用逻辑封装成组件，然后在规则链通过配置规则节点调用它。步骤：
1. 实现组件接口。
2. 把自定组件注册到注册器。
3. 通过规则链配置调用组件。

## 自定义组件

### 组件接口

实现[types.Node](https://github.com/rulego/rulego/blob/main/api/types/types.go)接口：

```go
// Node 节点组件接口
//把业务封或者通用逻辑装成组件，然后通过规则链配置方式调用该组件
type Node interface {
  //New 创建一个组件新实例
  //每个规则链的规则节点都会创建一个新的实例，数据是隔离的
  New() Node
  //Type 组件类型，类型不能重复。
  //用于规则链，node.type配置，初始化对应的组件
  //建议使用`/`区分命名空间，防止冲突。例如：x/httpClient
  Type() string
  //Init 组件初始化，一般做一些组件参数配置或者客户端初始化操作
  //规则链里的规则节点初始化会调用一次
  //Configuration 参数为节点配置数据
  Init(ruleConfig Config, configuration Configuration) error
  //OnMsg 处理消息，并控制流向子节点的关系。每条流入组件的数据会经过该方法处理
  //ctx:规则引擎处理消息上下文
  //msg:消息
  OnMsg(ctx RuleContext, msg RuleMsg)
  //Destroy 销毁，做一些资源释放操作
  Destroy()
}
```

### 生命周期

- **New:** 用于创建节点组件实例时调用。
- **Init:** 用于解析当前节点的JSON的配置，初始化规则链时候初始化一次。
- **OnMsg:** 用于处理消息，并控制流向子节点的关系。每条流入组件的数据会经过该函数处理。
- **Destroy:** 用于节点销毁时调用。规则引擎销毁时、规则链更新或节点配置更新时会调用该方法。
>如果动态更新节点配置，则先调用该节点新实例`Init`方法，如果初始化成功后，再调用旧实例的`Destroy`方法。

### 初始化
一般我们先定义该组件的配置结构体，配置结构体支持嵌套自定义结构体，嵌套结构体的字段只支持基础类型，另外需要使用json标签定义字段的编解码，字段格式使用小驼峰命名方式。
例如以下MQTT客户端配置结构体：
```go
type MqttClientNodeConfiguration struct {
	Server   string `json:"server"`
	Username string `json:"username"`
	Password string `json:"password"`
	// Topic 发布主题 可以使用 ${metadata.key} 读取元数据中的变量或者使用 ${msg.key} 读取消息负荷中的变量进行替换
	Topic string `json:"topic"`
	//MaxReconnectInterval 重连间隔 单位秒
	MaxReconnectInterval int `json:"maxReconnectInterval"`
	QOS                  uint8 `json:"qos"`
	CleanSession         bool `json:"cleanSession"`
	ClientID             string `json:"clientID"`
	CAFile               string `json:"cAFile"`
	CertFile             string `json:"certFile"`
	CertKeyFile          string `json:"certKeyFile"`
}
```
组件使用`Config`字段自定义组件配置（可视化编辑器会根据Config字段的结构体生成可视化节点配置）：
```go
type MqttClientNode struct {
	//节点配置
	Config MqttClientNodeConfiguration
	//topic 模板
	topicTemplate str.Template
	//客户端
	client        *mqtt.Client
}
```
> `global`,`vars`,`secrets`,`label`,`desc` ,`icon` 为保留字段。

然后在组件初始化时，把该节点的实例化配置转成组件配置结构体，例如以下节点配置：
```json
{
     "id": "s3",
     "type": "mqttClient",
     "name": "mqtt推送数据",
     "debugMode": false,
     "configuration": {
       "Server": "127.0.0.1:1883",
       "Topic": "/device/msg"
     }
}
```
Init方法 `configuration` 参数传递的就是该节点配置的`configuration`数据
```go
// Init 初始化
func (x *MqttClientNode) Init(ruleConfig types.Config, configuration types.Configuration) error {
	//把节点配置转成组件配置结构体
    err := maps.Map2Struct(configuration, &x.Config)
    //其他初始化
    return err
}
```
最后在OnMsg中，或者其他使用该配置
```go
// OnMsg 处理消息
func (x *MqttClientNode) OnMsg(ctx types.RuleContext, msg types.RuleMsg) {
	//使用配置
    topic:= x.Config.Topic,
}
```
### 处理消息

当前规则节点处理完后，把消息通过以下方法通知下一个或者多个节点。规则引擎会查询满足关系的子节点，并发触发其`OnMsg`方法，进行链式数据流调用
```go
//TellSuccess 通知规则引擎处理当前消息处理成功，并把消息通过`Success`关系发送到下一个节点
TellSuccess(msg RuleMsg)
//TellNext 使用指定的relationTypes，发送消息到下一个节点
TellNext(msg RuleMsg, relationTypes ...string)
//TellFailure 通知规则引擎处理当前消息处理失败，并把消息通过`Failure`关系发送到下一个节点
TellFailure(msg RuleMsg, err error)
```

示例：
```go
// OnMsg 处理消息
func (x *MqttClientNode) OnMsg(ctx types.RuleContext, msg types.RuleMsg) {
	//使用模板替换topic
	topic := x.topicTemplate.ExecuteFn(func() map[string]any {
		return base.NodeUtils.GetEvnAndMetadata(ctx, msg)
	})
	//获取mqtt客户端
	if client, err := x.SharedNode.Get(); err != nil {
		ctx.TellFailure(msg, err)
	} else {
		//把上一个节点的输出，发布到mqtt broker
		if err := client.Publish(topic, x.Config.QOS, []byte(msg.Data)); err != nil {
			//失败则通过失败链发送到下一个节点
			ctx.TellFailure(msg, err)
		} else {
			//成功则通过成功链发送到下一个节点，不改消息负荷
			ctx.TellSuccess(msg)
		}
	}
}
```

### 并发安全

在实现自定义组件时，需要特别注意**OnMsg()和Destroy()之间的并发安全问题**，特别是使用`SharedNode`的组件。

#### 🚨 重要警告：竞争条件风险

使用SharedNode的组件必须正确处理OnMsg()和Destroy()之间的竞争条件，否则可能导致：
- 使用已关闭的客户端连接
- 数据丢失或损坏
- 程序崩溃或资源泄漏

#### ❌ 错误的实现模式

```go
// 危险：存在竞争条件
type MyNode struct {
    base.SharedNode[*SomeClient]
    client *SomeClient
}

func (x *MyNode) OnMsg(ctx types.RuleContext, msg types.RuleMsg) {
    // 获取客户端
    client, err := x.SharedNode.Get()
    if err != nil {
        ctx.TellFailure(msg, err)
        return
    }
    
    // 危险区域：此时Destroy()可能被调用并关闭客户端
    // 使用可能已关闭的客户端 - 竞争条件！
    result, err := client.DoSomething(msg.GetData())
    if err != nil {
        ctx.TellFailure(msg, err)
    } else {
        msg.SetData(result)
        ctx.TellSuccess(msg)
    }
}

func (x *MyNode) Destroy() {
    // 强制关闭 - 可能打断正在进行的操作
    if x.client != nil {
        x.client.Close()
    }
}
```

#### ✅ 正确的实现模式

```go
// 安全：使用SharedNode并发安全机制
type MyNode struct {
    base.SharedNode[*SomeClient]
    client *SomeClient
}

func (x *MyNode) OnMsg(ctx types.RuleContext, msg types.RuleMsg) {
    // 1. 开始操作计数
    x.SharedNode.BeginOp()
    defer x.SharedNode.EndOp()

    // 2. 检查关闭状态
    if x.SharedNode.IsShuttingDown() {
        ctx.TellFailure(msg, fmt.Errorf("component is shutting down"))
        return
    }

    // 3. 获取客户端
    client, err := x.SharedNode.Get()
    if err != nil {
        ctx.TellFailure(msg, err)
        return
    }

    // 4. 再次检查关闭状态
    if x.SharedNode.IsShuttingDown() {
        ctx.TellFailure(msg, fmt.Errorf("component is shutting down"))
        return
    }

    // 5. 安全使用客户端
    result, err := client.DoSomething(msg.GetData())
    if err != nil {
        ctx.TellFailure(msg, err)
    } else {
        msg.SetData(result)
        ctx.TellSuccess(msg)
    }
}

func (x *MyNode) Destroy() {
    // 优雅关闭：等待活跃操作完成后再关闭资源
    x.SharedNode.GracefulShutdown(0, func() {
        // 只在非资源池模式下关闭本地资源
        if x.client != nil {
            x.client.Close()
            x.client = nil
        }
    })
}
```

#### SharedNode 并发安全要求清单

使用SharedNode的组件必须遵循以下并发安全原则：

✅ **OnMsg方法中：**
- 使用 `BeginOp()` / `EndOp()` 进行操作计数
- 在 `Get()` 前后检查 `IsShuttingDown()` 状态
- 实现优雅降级处理

✅ **Destroy方法中：**
- 使用 `GracefulShutdown()` 而不是直接关闭资源
- 等待活跃操作完成后再清理资源
- 避免强制中断正在进行的操作

✅ **资源管理：**
- 只在非资源池模式下关闭本地资源
- 将client字段设置为nil防止重复关闭
- 实现幂等的清理逻辑

#### 并发安全的重要性

正确的并发安全实现可以：
- 防止使用已关闭的连接导致的崩溃
- 确保数据完整性和一致性
- 提供优雅的服务降级能力
- 避免资源泄漏和内存泄漏

#### 通用并发安全要求

**所有**具有共享可变状态的组件都必须实现适当的并发安全机制，不仅仅是SharedNode组件：

#### ❌ 通用错误模式

```go
// 危险：任何有共享状态的组件都可能存在竞争条件
type MyNode struct {
    client      *SomeClient  // 共享可变状态
    config      Config       // 如果运行时修改也可能有问题
    counter     int64        // 共享计数器
    isConnected bool         // 共享状态标志
}

func (x *MyNode) OnMsg(ctx types.RuleContext, msg types.RuleMsg) {
    // 危险：检查-然后-使用竞争条件
    if x.client == nil {
        // ... 此时Destroy()可能被调用
        return
    }
    
    // 危险：使用可能已被修改的状态
    if !x.isConnected {
        return
    }
    
    // 危险：使用可能已关闭的client
    result := x.client.DoSomething()
    
    // 危险：非原子操作
    x.counter++
}

func (x *MyNode) Destroy() {
    // 危险：没有同步机制直接修改共享状态
    if x.client != nil {
        x.client.Close()
        x.client = nil
    }
    x.isConnected = false
}

func (x *MyNode) SomeOtherMethod() {
    // 危险：运行时修改配置
    x.config.SomeField = "new value"
}
```

#### ✅ 通用正确模式

```go
// 安全：使用适当的同步机制保护共享状态
type MyNode struct {
    // 共享状态字段
    client      *SomeClient
    config      Config
    counter     int64
    isConnected bool
    
    // 同步保护机制
    clientMutex     sync.RWMutex  // 保护client和isConnected
    configMutex     sync.RWMutex  // 保护config
    // 使用atomic操作保护counter，不需要mutex
}

func (x *MyNode) OnMsg(ctx types.RuleContext, msg types.RuleMsg) {
    // 安全：原子性获取共享状态
    x.clientMutex.RLock()
    client := x.client
    connected := x.isConnected
    x.clientMutex.RUnlock()
    
    if client == nil || !connected {
        ctx.TellFailure(msg, fmt.Errorf("client not available"))
        return
    }
    
    // 安全：使用本地副本，避免并发修改
    result := client.DoSomething()
    
    // 安全：原子操作
    atomic.AddInt64(&x.counter, 1)
    
    ctx.TellSuccess(msg)
}

func (x *MyNode) Destroy() {
    // 安全：使用写锁保护状态修改
    x.clientMutex.Lock()
    defer x.clientMutex.Unlock()
    
    if x.client != nil {
        _ = x.client.Close()
        x.client = nil
    }
    x.isConnected = false
}

func (x *MyNode) UpdateConfig(newConfig Config) {
    // 安全：配置更新也需要同步保护
    x.configMutex.Lock()
    defer x.configMutex.Unlock()
    x.config = newConfig
}

func (x *MyNode) getConfig() Config {
    // 安全：读取配置使用读锁
    x.configMutex.RLock()
    defer x.configMutex.RUnlock()
    return x.config
}
```

#### 并发安全核心原则

1. **识别共享状态**：
   - 客户端连接（database、HTTP、TCP等）
   - 配置信息（如果运行时可修改）
   - 计数器、状态标志
   - 缓存、缓冲区

2. **选择合适的同步机制**：
   - `sync.RWMutex`：保护复杂结构体、连接对象
   - `sync.Mutex`：保护简单状态、独占访问
   - `atomic`操作：保护计数器、简单数值
   - `sync.Once`：确保只执行一次的初始化

3. **避免常见陷阱**：
   - 检查-然后-使用竞争条件
   - 持有锁时间过长
   - 嵌套锁导致死锁
   - 忘记保护"读取"操作

4. **最佳实践**：
   - 最小化锁的粒度和持有时间
   - 使用defer确保锁的释放
   - 优先使用读锁进行读操作
   - 在函数返回前获取状态的本地副本

> **重要提醒**：即使是"简单"的组件，只要有共享可变状态，就需要考虑并发安全！

### SharedNode 专用要求

对于使用SharedNode的组件，除了通用要求外，还需要：

### 详细节点执行控制上下文接口

节点接口中处理消息函数：`OnMsg(ctx RuleContext, msg RuleMsg)`，其中执行上下文`ctx`可以对规则引擎节点进行流转已经编排控制。

`ctx`接口定义如下：
```go
// RuleContext 是规则引擎中消息处理上下文的接口。
// 它将消息传递到下一个或多个节点。并触发它们的业务逻辑。
// 以及对本次执行实例的节点流程进行控制和编排
type RuleContext interface {
	// TellSuccess 通知规则引擎当前消息已成功处理，并通过 'Success' 关系将消息发送到下一个节点。
	TellSuccess(msg RuleMsg)
	// TellFailure 通知规则引擎当前消息处理失败，并通过 'Failure' 关系将消息发送到下一个节点。
	TellFailure(msg RuleMsg, err error)
	// TellNext 使用指定的 relationTypes 将消息发送到下一个节点。
	TellNext(msg RuleMsg, relationTypes ...string)
	// TellSelf 在指定的延迟（毫秒）后将消息发送到当前节点。
	TellSelf(msg RuleMsg, delayMs int64)
	// TellNextOrElse 使用指定的 relationTypes 将消息发送到下一个节点。如果相应的 relationType 没有找到下一个节点，则使用 defaultRelationType 进行搜索。
	TellNextOrElse(msg RuleMsg, defaultRelationType string, relationTypes ...string)
	// TellFlow 执行子规则链。
	TellFlow(ctx context.Context, ruleChainId string, msg RuleMsg, endFunc OnEndFunc, onAllNodeCompleted func())
	// TellNode 从指定节点开始执行。如果 skipTellNext=true，则只执行当前节点，不通知下一个节点。
	// onEnd 用于查看最终执行结果。
	TellNode(ctx context.Context, nodeId string, msg RuleMsg, skipTellNext bool, onEnd OnEndFunc, onAllNodeCompleted func())
	// NewMsg 创建一个新消息实例。
	NewMsg(msgType string, metaData Metadata, data string) RuleMsg
	// GetSelfId 检索当前节点 ID。
	GetSelfId() string
	// Self 检索当前节点实例。
	Self() NodeCtx
	// From 检索消息进入当前节点的节点实例。
	From() NodeCtx
	// RuleChain 检索当前节点所在的规则链实例。
	RuleChain() NodeCtx
	// Config 检索规则引擎的配置。
	Config() Config
	// SubmitTack 提交一个异步任务以供执行。
	SubmitTack(task func())
	// SetEndFunc 设置当前消息处理结束时的回调函数。
	SetEndFunc(f OnEndFunc) RuleContext
	// GetEndFunc 检索当前消息处理结束时的回调函数。
	GetEndFunc() OnEndFunc
	// SetContext 设置共享信号量或数据的上下文，跨不同组件实例。
	SetContext(c context.Context) RuleContext
	// GetContext 检索共享信号量或数据的上下文，跨不同组件实例。
	GetContext() context.Context
	// SetOnAllNodeCompleted 设置所有节点执行完成时的回调。
	SetOnAllNodeCompleted(onAllNodeCompleted func())
	// DoOnEnd 触发 OnEnd 回调函数。
	DoOnEnd(msg RuleMsg, err error, relationType string)
	// SetCallbackFunc 设置回调函数。
	SetCallbackFunc(functionName string, f interface{})
	// GetCallbackFunc 检索回调函数。
	GetCallbackFunc(functionName string) interface{}
	// OnDebug 调用配置的 OnDebug 回调函数。
	OnDebug(ruleChainId string, flowType string, nodeId string, msg RuleMsg, relationType string, err error)
	// SetExecuteNode 设置当前节点。
	// 如果 relationTypes 为空，则执行当前节点；否则，
	// 查找并执行当前节点的子节点。
	SetExecuteNode(nodeId string, relationTypes ...string)
}
```

### 示例

实现[types.Node](https://github.com/rulego/rulego/blob/main/api/types/types.go)接口，定义组件：

```go
//UpperNode A plugin that converts the message data to uppercase
type UpperNode struct{}

func (n *UpperNode) Type() string {
   return "test/upper"
}
func (n *UpperNode) New() types.Node {
  return &UpperNode{}
}
func (n *UpperNode) Init(ruleConfig types.Config, configuration types.Configuration) error {
  // Do some initialization work
  return nil
}
//处理消息
func (n *UpperNode) OnMsg(ctx types.RuleContext, msg types.RuleMsg)  {
  msg.Data = strings.ToUpper(msg.Data)
  // Send the modified message to the next node
  ctx.TellSuccess(msg)
}

func (n *UpperNode) Destroy() {
// Do some cleanup work
}
```

把组件注册到注册器：
```go
rulego.Registry.Register(&MyNode{})
```

然后在规则链文件使用你的自定义组件：

``` json
{
  "ruleChain": {
    "name": "测试规则链",
    "root": true,
    "debugMode": false
  },
  "metadata": {
    "nodes": [
      {
        "id": "s1",
        "type": "test/upper",
        "name": "名称",
        "debugMode": true,
        "configuration": {
          "field1": "组件定义的配置参数",
          "....": "..."
        }
      }
    ],
    "connections": [
      {
        "fromId": "s1",
        "toId": "连接下一个组件ID",
        "type": "与组件的连接关系"
      }
    ]
  }
}
```

## `go plugin` 方式提供组件

这种方式支持动态加载组件，但是只能支持非windows系统。 一个插件可以提供多个组件。    

实现[types.PluginRegistry](https://github.com/rulego/rulego/blob/main/api/types/types.go)接口。
并导出变量名称:`Plugins`,参考[examples/plugin](https://github.com/rulego/rulego/tree/main/examples/plugin)

### 示例
实现[types.PluginRegistry](https://github.com/rulego/rulego/blob/main/api/types/types.go)接口

```go
// 导出插件变量
var Plugins MyPlugins

type MyPlugins struct{}

func (p *MyPlugins) Init() error {
    return nil
}
func (p *MyPlugins) Components() []types.Node {
  //一个插件可以提供多个组件
  return []types.Node{&UpperNode{}, &TimeNode{}, &FilterNode{}}
}
```

编译插件：
``` shell
#编译插件，生成plugin.so文件，需要在mac或者linux环境下编译
go build -buildmode=plugin -o plugin.so plugin.go
```

把组件注册到注册器：
```go
rulego.Registry.RegisterPlugin("test", "./plugin.so")
```

## 可视化
- [组件配置表单约定](/pages/af0195/)
- 自定义组件可视化参考：[获取组件配置表单](/pages/cf0194/) 章节

## 贡献组件

RuleGo 的核心特性是组件化，所有业务逻辑都是组件，并能灵活配置和重用它们。目前RuleGo 已经内置了大量常用的组件。     
但是，我们知道这些组件还远远不能满足所有用户的需求，所以我们希望能有更多的开发者为 RuleGo 贡献扩展组件，让 RuleGo 的生态更加丰富和强大。

* 如果您提交的组件代码没有第三方依赖或者是通用性组件请提交到主库下的标准组件[components](https://github.com/rulego/rulego) 
* 常用组件提交到扩展组件仓库：[rulego-components](https://github.com/rulego/rulego-components)
* CI/CD相关组件提交到：[rulego-components-ci](https://github.com/rulego/rulego-components-ci)
* AI相关组件提交到：[rulego-components-ai](https://github.com/rulego/rulego-components-ai)
* IoT相关组件提交到：[rulego-components-iot](https://github.com/rulego/rulego-components-iot)
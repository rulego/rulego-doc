---
title: 获取节点输出
article: false
author: 
  name: rulego
  link: https://github.com/rulego/rulego
date: 2025-01-27 10:00:00
permalink: /pages/fetch-node-output/
---

`fetchNodeOutput`组件：<Badge text="v0.33.0+"/> 获取指定节点输出的组件。用于获取目标节点的输出消息并传递给下一个节点。

## 背景说明

在传统的规则链处理中，组件只能获取上一个节点的输出作为输入，这在某些复杂场景下存在限制。例如在条件分支处理后，需要获取分支中某个特定节点的输出数据时，传统方式无法直接实现。

`fetchNodeOutput`组件解决了这个问题，它允许获取规则链中任意已执行节点的输出，实现真正的跨节点数据传递。

## 功能特性

- **跨节点数据传递**：通过节点ID获取目标节点的输出消息，突破传统的线性数据流限制
- **自动依赖管理**：自动建立节点依赖关系以启用输出缓存
- **输出复用**：支持多个节点复用同一节点的输出数据
- **条件分支合并**：适用于条件分支后的数据合并场景
- **灵活的数据获取**：可以获取规则链中任意已执行节点的输出，不受节点执行顺序限制

## 配置

| 字段 | 类型     | 说明   | 默认值 |
|----|--------|------|--------|
| nodeId   | string | 目标节点ID，获取该节点的输出消息 | 无|

## 工作原理

### 依赖关系机制

该组件采用依赖关系机制来确保目标节点的输出能够被访问：

1. **初始化阶段**：在`Init()`方法中自动调用`chainCtx.AddNodeDependency()`建立依赖关系
2. **输出缓存**：只有建立依赖关系的节点才会缓存输出数据
3. **数据访问**：通过`GetNodeRuleMsg()`方法访问目标节点的缓存输出

### 执行流程

1. 组件接收到消息后，通过`nodeId`查找目标节点的输出
2. 如果找到目标节点的输出，将其传递给成功链路
3. 如果未找到输出或依赖关系未建立，将原消息传递给失败链路

## 使用场景

### 跨节点数据传递

```json
{
  "id": "fetchOutput1",
  "type": "fetchNodeOutput",
  "name": "获取数据处理结果",
  "configuration": {
    "nodeId": "dataProcessor"
  }
}
```

### 条件分支合并

```json
{
  "ruleChain": {
    "name": "条件分支处理",
    "root": true,
    "debugMode": false
  },
  "metadata": {
    "nodes": [
      {
        "id": "condition",
        "type": "jsFilter",
        "name": "条件判断",
        "configuration": {
          "jsScript": "return msg.temperature > 30;"
        }
      },
      {
        "id": "highTempProcess",
        "type": "jsTransform",
        "name": "高温处理",
        "configuration": {
          "jsScript": "msg.alert = 'high temperature'; return {msg: msg, metadata: metadata, msgType: msgType};"
        }
      },
      {
        "id": "normalProcess",
        "type": "jsTransform",
        "name": "正常处理",
        "configuration": {
          "jsScript": "msg.status = 'normal'; return {msg: msg, metadata: metadata, msgType: msgType};"
        }
      },
      {
        "id": "fetchHigh",
        "type": "fetchNodeOutput",
        "name": "获取高温处理结果",
        "configuration": {
          "nodeId": "highTempProcess"
        }
      },
      {
        "id": "fetchNormal",
        "type": "fetchNodeOutput",
        "name": "获取正常处理结果",
        "configuration": {
          "nodeId": "normalProcess"
        }
      },
      {
        "id": "finalLog",
        "type": "log",
        "name": "最终日志",
        "configuration": {
          "jsScript": "return 'Final result: ' + JSON.stringify(msg);"
        }
      }
    ],
    "connections": [
      {
        "fromId": "condition",
        "toId": "highTempProcess",
        "type": "True"
      },
      {
        "fromId": "condition",
        "toId": "normalProcess",
        "type": "False"
      },
      {
        "fromId": "highTempProcess",
        "toId": "fetchNormal",
        "type": "Success"
      },
      {
        "fromId": "normalProcess",
        "toId": "fetchHigh",
        "type": "Success"
      },
      {
        "fromId": "fetchHigh",
        "toId": "finalLog",
        "type": "Success"
      },
      {
        "fromId": "fetchNormal",
        "toId": "finalLog",
        "type": "Success"
      }
    ]
  }
}
```

## 使用指南

:::warning 重要提示
- 必须确保目标节点ID存在且已执行完成
- 依赖关系在组件初始化时自动建立，无需手动配置
- 如果目标节点未产生输出或依赖关系未建立，消息将被路由到失败链路
- **建议在规则链设计时合理规划节点执行顺序，优先考虑数据流的自然传递，避免过度依赖跨节点数据传递**
:::

:::tip 最佳实践
- 使用该组件前确保目标节点已经执行并产生输出
- 在复杂的条件分支场景中，可以使用多个`fetchNodeOutput`组件来收集不同分支的结果
- 结合其他组件（如`jsTransform`）可以对获取的输出进行进一步处理
- 除了使用`fetchNodeOutput`组件外，还可以通过[组件配置变量](/pages/baa05c/)的方式获取其他节点的输出，例如：`${node1.msg.temperature}`、`${sensor2.metadata.deviceId}`等
- 优先设计线性或树状的数据流结构，减少节点间的交叉依赖
:::
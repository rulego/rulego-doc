---
title: 结束节点
article: false
author: 
  name: rulego
  link: https://github.com/rulego/rulego
date: 2025-01-27 10:00:00
permalink: /pages/end01/
---

`end`组件：<Badge text="v0.33.0+"/> 结束节点。用于触发规则链的结束回调。如果规则链设置了结束节点组件，则会替代默认的分支结束行为，只有运行到结束节点组件时，才会触发结束回调。

## 功能说明

1. **接收消息并触发DoOnEnd回调** - 当消息到达end节点时，会立即触发规则链的结束回调
2. **使用上一个节点传入的关系类型** - 保持消息流的关系类型传递
3. **不会继续传递消息到下一个节点** - 作为规则链的终点，不再向后传递消息

## 使用场景

- **规则链的明确结束点** - 在复杂的规则链中明确标识结束位置
- **触发特定的结束处理逻辑** - 在特定条件下触发结束回调
- **替代默认的分支结束行为** - 控制何时触发OnEnd回调

## 重要说明

**如果需要规则链只有一个返回，在分支增加这个节点，规则链只会在这个节点触发OnEnd回调，否则每个结束分支都会调用OnEnd回调。**

这意味着：
- 没有end节点：每个分支结束时都会触发OnEnd回调
- 有end节点：只有到达end节点时才会触发OnEnd回调，其他分支结束不会触发

## 配置

end组件无需任何配置参数。

## Relation Type

end组件不产生新的关系类型，它使用上一个节点传入的关系类型来触发DoOnEnd回调。

## 配置示例

```json
{
  "ruleChain": {
    "id": "rule01",
    "name": "测试规则链",
    "root": true,
    "debugMode": false
  },
  "metadata": {
    "nodes": [
      {
        "id": "s1",
        "type": "jsFilter",
        "name": "过滤器",
        "debugMode": true,
        "configuration": {
          "jsScript": "return msg.temperature > 50;"
        }
      },
      {
        "id": "s2",
        "type": "log",
        "name": "记录日志",
        "debugMode": true,
        "configuration": {
          "jsScript": "return 'temperature:' + msg.temperature;"
        }
      },
      {
        "id": "s3",
        "type": "end",
        "name": "结束节点",
        "debugMode": true
      }
    ],
    "connections": [
      {
        "fromId": "s1",
        "toId": "s2",
        "type": "True"
      },
      {
        "fromId": "s2",
        "toId": "s3",
        "type": "Success"
      }
    ],
    "ruleChainConnections": null
  }
}
```

## 应用示例

### 场景1：单一结束点

```go
// 创建规则引擎
ruleEngine, err := rulego.New("rule01", []byte(ruleChainFile))
if err != nil {
    panic(err)
}

// 设置结束回调
ruleEngine.OnEnd(func(ctx types.RuleContext, msg types.RuleMsg, err error, relationType string) {
    fmt.Printf("规则链结束: relationType=%s, data=%s\n", relationType, msg.Data)
})

// 发送消息
msg := types.NewMsg(0, "TELEMETRY", types.JSON, `{"temperature":60}`)
ruleEngine.OnMsg(msg)
```

### 场景2：多分支但单一结束点

```json
{
  "metadata": {
    "nodes": [
      {
        "id": "filter",
        "type": "jsFilter",
        "configuration": {
          "jsScript": "return msg.temperature > 50;"
        }
      },
      {
        "id": "highTemp",
        "type": "log",
        "configuration": {
          "jsScript": "return '高温告警:' + msg.temperature;"
        }
      },
      {
        "id": "normalTemp",
        "type": "log",
        "configuration": {
          "jsScript": "return '正常温度:' + msg.temperature;"
        }
      },
      {
        "id": "end",
        "type": "end",
        "name": "统一结束点"
      }
    ],
    "connections": [
      {
        "fromId": "filter",
        "toId": "highTemp",
        "type": "True"
      },
      {
        "fromId": "filter",
        "toId": "normalTemp",
        "type": "False"
      },
      {
        "fromId": "highTemp",
        "toId": "end",
        "type": "Success"
      },
      {
        "fromId": "normalTemp",
        "toId": "end",
        "type": "Success"
      }
    ]
  }
}
```

在这个例子中，无论消息走哪个分支，最终都会到达end节点，确保OnEnd回调只被触发一次。

## 注意事项

1. **end节点不需要任何配置参数**
2. **end节点不会向下游传递消息**
3. **使用end节点可以精确控制OnEnd回调的触发时机**
4. **在复杂的多分支规则链中，建议使用end节点来统一结束点**
5. **end节点会保持上游节点传入的关系类型**
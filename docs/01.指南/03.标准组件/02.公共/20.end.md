---
title: 结束节点
article: false
author: 
  name: rulego
  link: https://github.com/rulego/rulego
date: 2025-01-27 10:00:00
permalink: /pages/end/
---

`end`组件：<Badge text="v0.33.0+"/> 结束节点。用于触发规则链的结束回调。如果规则链设置了结束节点组件，则会替代默认的分支结束行为，只有运行到结束节点组件时，才会触发结束回调。

::: danger 注意事项
1. 非必要不要使用该节点，使用该节点，必须确保规则链会最终调用它，否则会导致规则链无法结束。也就是说，如果规则链添加了【结束】节点，所有结束分支必须都要和这个节点连接（除非这些分支是并发执行的）。
2. [Config.OnEndWithFailure=true](/pages/config/#onendwithfailure) ，可以避免因为异常或者Failure分支没有连接End节点，导致规则链无法结束的问题。
:::
示例：
<img src="/img/end_example.png" width=500 >
## 功能说明

1. **接收消息并触发DoOnEnd回调** - 当消息到达end节点时，会立即触发规则链的结束回调
2. **使用上一个节点传入的关系类型** - 保持消息流的关系类型传递
3. **不会继续传递消息到下一个节点** - 作为规则链的终点，不再向后传递消息

## 使用场景

- **规则链的明确结束点** - 在复杂的规则链中明确标识结束位置
- **触发特定的结束处理逻辑** - 在特定条件下触发结束回调
- **替代默认的分支结束行为** - 控制何时触发OnEnd回调

## 重要说明

**如果需要规则链只有一个返回，在分支增加这个节点，规则链只会在这个节点触发OnEnd回调，否则每个结束分支都会调用OnEnd回调。**

这意味着：
- 没有end节点：每个分支结束时都会触发OnEnd回调
- 有end节点：只有到达end节点时才会触发OnEnd回调，其他分支结束不会触发

## 配置

end组件无需任何配置参数。

## Relation Type

end组件不产生新的关系类型，它使用上一个节点传入的关系类型来触发DoOnEnd回调。

## 配置示例

```json
{
  "ruleChain": {
    "id": "rule01",
    "name": "测试规则链",
    "root": true,
    "debugMode": false
  },
  "metadata": {
    "nodes": [
      {
        "id": "s1",
        "type": "jsFilter",
        "name": "过滤器",
        "debugMode": true,
        "configuration": {
          "jsScript": "return msg.temperature > 50;"
        }
      },
      {
        "id": "s2",
        "type": "log",
        "name": "记录日志",
        "debugMode": true,
        "configuration": {
          "jsScript": "return 'temperature:' + msg.temperature;"
        }
      },
      {
        "id": "s3",
        "type": "end",
        "name": "结束节点",
        "debugMode": true
      }
    ],
    "connections": [
      {
        "fromId": "s1",
        "toId": "s2",
        "type": "True"
      },
      {
        "fromId": "s2",
        "toId": "s3",
        "type": "Success"
      }
    ],
    "ruleChainConnections": null
  }
}
```

## 应用示例

### 场景1：单一结束点

```go
// 创建规则引擎
ruleEngine, err := rulego.New("rule01", []byte(ruleChainFile))
if err != nil {
    panic(err)
}

// 设置结束回调
ruleEngine.OnEnd(func(ctx types.RuleContext, msg types.RuleMsg, err error, relationType string) {
    fmt.Printf("规则链结束: relationType=%s, data=%s\n", relationType, msg.Data)
})

// 发送消息
msg := types.NewMsg(0, "TELEMETRY", types.JSON, `{"temperature":60}`)
ruleEngine.OnMsg(msg)
```

### 场景2：多分支但单一结束点

```json
{
  "metadata": {
    "nodes": [
      {
        "id": "filter",
        "type": "jsFilter",
        "configuration": {
          "jsScript": "return msg.temperature > 50;"
        }
      },
      {
        "id": "highTemp",
        "type": "log",
        "configuration": {
          "jsScript": "return '高温告警:' + msg.temperature;"
        }
      },
      {
        "id": "normalTemp",
        "type": "log",
        "configuration": {
          "jsScript": "return '正常温度:' + msg.temperature;"
        }
      },
      {
        "id": "end",
        "type": "end",
        "name": "统一结束点"
      }
    ],
    "connections": [
      {
        "fromId": "filter",
        "toId": "highTemp",
        "type": "True"
      },
      {
        "fromId": "filter",
        "toId": "normalTemp",
        "type": "False"
      },
      {
        "fromId": "highTemp",
        "toId": "end",
        "type": "Success"
      },
      {
        "fromId": "normalTemp",
        "toId": "end",
        "type": "Success"
      }
    ]
  }
}
```

在这个例子中，无论消息走哪个分支，最终都会到达end节点，确保OnEnd回调只被触发一次。

## 注意事项

1. **end节点不需要任何配置参数**
2. **end节点不会向下游传递消息**
3. **使用end节点可以精确控制OnEnd回调的触发时机**
4. **非必要不要使用该节点。如果使用该节点，必须确保规则链会最终调用它，否则会导致规则链无法结束。**
5. **Config.OnEndWithFailure** 默认为 true。表示没有找到连接的节点，并且当关系类型为 Failure 时，也会触发 OnEnd 回调，不管是否有End节点。设置Config.
